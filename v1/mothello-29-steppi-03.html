<head>
<title>MoThello</title>
<script>

    // ====================================================================
    //  MoThello Version 2008-08-20. Inspired by MoGo.
    //  (c) 2008 by Dietrich Raisin, info1@raisin.de, www.raisin.de
    //
    //  Released under the Artistic License 2.0. Here are the terms:
    //  http://www.opensource.org/licenses/artistic-license-2.0.php
    //
    //  To make a copy, this file is the only one you need. No images were
    //  used, the stones are unicode characters.
    //
    //  Lessons learned:
    //  - Hashes are slow
    //  - Function calls are slow
    //  - Generating new arrays is slow
    //  - JITs may be slower (MoThello is slower on Tamarin and V8)
    // ====================================================================

    if (typeof console == 'undefined') {

        // Firebug Feather :-)
        console= {
            log: function(value) {
                var lines= document.getElementById('console').innerHTML.split('<br>');
                lines.push(value);
                while (lines.length > 15) lines.shift();
                document.getElementById('console').innerHTML= lines.join('<br>');
            }
        };
    }

    var boardLog;               // Log of the moves made

    var posH;                   // Board from a horizontal point of view
    var posV;                   // Board from a vertical point of view
    var posDiag1;               // Board from a diagonal point of view
    var posDiag2;               // Board from the other diagonal point of view

    var col;                    // Current player's color. 1 (white) or 2 (black).
    var colMask;                // 0 if col == 1, or 0xFFFF if col == 2
    var colDiff;                // 1 if col == 1, or -1 if col == 2
    
    var diff;                   // Current score (if positive, points that white is ahead, otherwise -points that black is ahead)

    var posList;                // See initPosList
    var initPosListDone;
    
    var undefined= undefined;   // jQuery does that. So it's correct. qed.

    var getValidMoves;          // Function generated by makeGetValidMoves()
    var validMovesCheck;        // Flag indicating if the board is already initialized
    var validMoves;

    var zero64;                 // 64 x 0

    var hStatusTimer= null;     // Used by status(). Timer for switching back the status information to default value

    var endTime= 0;             // Used by computeMove()
    var stopCalculating;

    var cellScore;

    var setAt;

    var computerCol= 0;
    var oldComputerCol= 0;

    // ====================================================================
    //  Core
    // ====================================================================

    function initCellScore() {

        // Generates a basic Scoring (how intense will a certain postition be looked at):
        // 6 4 4 4 ..
        // 4 1 2 2 ..
        // 4 2 4 2 ..
        // 4 2 2 2 ..
        // ..

        cellScore= [];
        for (var i= 0; i < 64; i++) {
            cellScore[i]= 2;
        }

        for (var i= 0; i < 8; i++) {
            cellScore[i] += 2;
            cellScore[i * 8] += 2;
            cellScore[i + 56] += 2;
            cellScore[i * 8 + 7] += 2;
        }
        for (var i= 2; i < 6; i++) {
            cellScore[i + 16]++;
            cellScore[i * 8 + 2]++;
            cellScore[i + 40]++;
            cellScore[i * 8 + 5]++;
        }
        cellScore[9]= cellScore[14]= cellScore[49]= cellScore[54]= 1;
    }

    function initBoard() {
        posH= [];
        posV= [];
        posDiag1= [];
        posDiag2= [];
        
        for (var y= 8; y--; ) {
            posH.push(0);
            posV.push(0);
        }

        for (var y= 15; y--; ) {
            posDiag1.push(0);
            posDiag2.push(0);
        }

        boardLog= [];

        // Black begins
        col= 2;
        colMask= 65535;
        colDiff= -1;

        stopCalculating= 0;
        
        diff= 0;

        validMoves= [];

        // Set the 4 center pieces
        setAt[28]();
        setAt[27]();
        setAt[35]();
        setAt[36]();
    }

    //  The entries for all possible positions for one row are stored in the
    //  posList array. The index consists of 2 * 8 bits for the 8 cells. 2 bits
    //  are used as follows: 0= empty, 1=white, 2=black, 3=empty.
    //
    //  The entries can be used for either opponent. One of the opponent
    //  looks up posList[n], the other posList[n ^ 0xffff].
    //
    //  Each entry looks like this:
    //  [ valid2, valid1, valid0,
    //      newpos0, newpos1, ... , newpos7,
    //      flipped0-left, flipped0-right, flipped1-left, flipped1-right, ... , flipped7-left, flipped7-right,
    //  ]
    //
    //  validN      0..  Valid moves for white in that position.
    //
    //  newposN     3..  New position if white's move is N.
    //              The new position includes the flipped captures stones if there are any.
    //
    //  flippedN    11.. Number of flipped stones to the left and to the right if white's move is N.
    //
    function initPosList() {
    
        initPosListDone= 0;
        posList= new Array(65536);

        var pos0= 0;

        var nextChunk= function() {

            var pos,
                had, had1pos,
                want1, want2, wantpos,
                j,
                valid,
                newpos, flipped;

            for (chunk= 8192; chunk--; pos0++) {
    
                pos= pos0;
                had= want1= want2= 0;
                had1pos= wantpos= -1;
                valid= [ 9, 9, 9 ];
                newpos= [ pos0, pos0, pos0, pos0, pos0, pos0, pos0, pos0 ];
                flipped= [ 0, 0,  0, 0,  0, 0,  0, 0,  0, 0,  0, 0,  0, 0,  0, 0 ];
                validi= 0;
    
                for (j= 0; j < 8; j++) {

                    if ((pos & 3) == 1) {
                        if (wantpos >= 0) {
                            if (want2) {
                                valid[validi++]= wantpos;
                                
                                // Flip captured stones
                                newpos[wantpos] ^=
                                    ~(-1 << (j + j - wantpos - wantpos - 2))
                                    << (wantpos + wantpos + 2);
                                flipped[wantpos + wantpos + 1]= j - wantpos -1;
                            }
                            wantpos= -1;
                        }
                        had= 1;
                        want2= 0;
                        newpos[j]= undefined;
                    }
                    else if ((pos & 3) == 2) {
                        if (had == 1) {
                            had= 2;
                            had1pos= j;
                        }
                        want2= 1;
                        newpos[j]= undefined;
                    }
                    else {
                        if (had == 2) {
                            valid[validi++]= j;

                            // Flip captured stones
                            newpos[j] ^=
                                ~(-1 << (j + j - had1pos - had1pos))
                                << (had1pos + had1pos);
                            flipped[j + j]= j - had1pos;
                        }
                        wantpos= j;
                        had= want1= want2= 0;

                        newpos[j]= newpos[j] & ~(3 << (j + j)) | (1 << (j + j));
                    }

                    pos >>= 2;
                }

                // Additionally to it's purpose of concating, "concat" clones the array, which is
                // what we need here.
                posList[pos0]= valid.sort().concat(newpos).concat(flipped); // .concat(set1).concat(set2);

                // console.log(valid);
            }
            if (pos0 < 65536) {
                setTimeout(nextChunk, 1);
                return;
            }
            initPosListDone= 1;
            console.log("initPosList DONE");
        }
        setTimeout(nextChunk, 1);
    }

    // Builds an optimized function that calculates the valid moves.
    // The resulting function is fast, but still contains to many loops
    // and ifs, so I'm not very happy about it yet.
    // It's pretty much the bootleneck of the whole computaion.
    // At least that's what Firebug says.
    //
    function makeGetValidMoves() {

        var result= [];

        result.push(""
            , " function() {"
            , "     var cellScore2= cellScore.concat();"
            , "     var valid, cell, score;"
            , "     var result= [];"
        );

        var checkValid= function(posArray, move, base, mul, len) {

            result.push(""
                , "     valid= posList[" + posArray + "[" + move + "] ^ colMask];"
            );

            if (mul == -1) mul= ' - ';
            else if (mul == 1) mul= (base ? ' + ' : '');
            else if (mul > 0) mul= (base ? ' + ' : '') + mul + ' * ';
            else mul= (base ? ' - ' : ' -') + -mul + ' * ';

            if (base == 0) base= '';

            for (var i= 0; i < 3; i++) {
                result.push(""
                    , "     if (valid[" + i + "] < " + len + ") {"
                    , "         if (score= cellScore2[" + base + mul + "valid[" + i + "]]) {"
                    , "             cell= " + base + mul + "valid[" + i + "];"
                    , "             cellScore2[cell]= 0;"
                    , "             while (score--) result[result.length]= cell;"
                    , "         }"
                );
            };
            result.push(""
                , "     }}}"
            );
        }

        for (var i= 0; i < 8; i++) {
            checkValid('posH',      i, i * 8, 1, 8);
            checkValid('posV',      i, i,     8, 8);
        }
        for (var i= 2; i < 8; i++) {
            checkValid('posDiag1',  i, 7 - i, 9,  i + 1);
            checkValid('posDiag2',  i, i * 8, -7, i + 1);
        }
        for (var i= 8; i < 13; i++) {
            checkValid('posDiag1',  i, (i - 7) * 8, 9,  15 - i);
            checkValid('posDiag2',  i, 49 + i,      -7, 15 - i);
        }

        result.push(""
            , "     if (result.length) return result;"
            , "     return [ 64 ];"     // pass
            , " }"
        );

        // console.log(result.join("\n"));

        eval("getValidMoves= (" + result.join('') + ");");
    }

    function unique(a) {
        var lookup= [];
        var result= [];
        for (var i= a.length; i--; ) {
            if (lookup[a[i]] == undefined) result[result.length]= a[i];
            lookup[a[i]]= 1;
        }
        return result;
    }

    // Generate specialized function for making a the specified move.
    // The produced code does pretty well nothing superfluous. Most
    // values can be prcomputed so it mainly uses constants and no loops.
    // So it's fast. If you can make it faster, please let me know!
    //
    function makeSetAt(move) {

        var movey= move >> 3;
        var movex= move & 7;

        var result= [];

        var shl= function(name, value) {
            if (value) return '(' + name + ' << ' + value + ')';
            return name;
        };

        var encloseIfContainsCode= function(aBefore, aAfter, func) {
            var lastLength= result.length;
            func();
            if (lastLength != result.length) {
                for (i in aBefore) result.splice(lastLength++, 0, aBefore[i]);
                for (i in aAfter) result.splice(result.length, 0, aAfter[i]);
            }
        };

        // fixme: name turn
        var flip= function(posIndex, dx, dy) {

            encloseIfContainsCode([ ""
                    , "     if (qi= pos[" + posIndex + "]) {"
                ], [ ""
                    , "}"
                ], function() {

                    var moveHVx= movex;
                    var moveHVy= movey;
        
                    var brackets= '';
                    var found= 0;

                    for (var max= 1; max < 7; max++) {
        
                        moveHVx += dx;
                        if (moveHVx < 0 || moveHVx >= 8) break;

                        moveHVy += dy;
                        if (moveHVy < 0 || moveHVy >= 8) break;

                        found= max;
                                
                        var moveHVx2= moveHVx + moveHVx;
                        var moveHVy2= moveHVy + moveHVy;
        
                        var moveDiag1x= moveHVx >= moveHVy ? moveHVy2 : moveHVx2;
                        var moveDiag1y= moveHVy - moveHVx + 7;
        
                        var moveDiag2x= (7 - moveHVx) >= moveHVy ? moveHVx2 : 14 - moveHVy2;
                        var moveDiag2y= moveHVy + moveHVx;
        
                        if (max > 1) {
                            result.push(""
                                , "     if (qi >= " + max + ") {"
                            );
                            brackets += '}';
                        }
                        
                        result.push(""
                            , "         posH[" + moveHVy + "] ^= " + ((3 << moveHVx2)) + ";"
                            , "         posV[" + moveHVx + "] ^= " + ((3 << moveHVy2)) + ";"
                            , "         posDiag1[" + moveDiag1y + "] ^= " + ((3 << moveDiag1x)) + ";"
                            , "         posDiag2[" + moveDiag2y + "] ^= " + ((3 << moveDiag2x)) + ";"
                        );
                    }

                    if (brackets.length) result.push(""
                        , '     ' + brackets
                    );
                    if (found == 1) {
                        result.push(""
                            , "         diff += colDiff + colDiff;"
                        );
                    }                    
                    else if (found > 1) {
                        result.push(""
                            , "         diff += (colDiff + colDiff) * qi;"
                        );
                    }                    
                }
            );
        };

        var movex2= movex + movex;
        var movey2= movey + movey;

        var movedax= movex >= movey ? movey2 : movex2;
        var moveday= movey - movex + 7;

        var movedbx= (7 - movex) >= movey ? movex2 : 14 - movey2;
        var movedby= movey + movex;

        result.push(""
            , " function() {"
            , "     var pos, qi;"
            , "     boardLog[boardLog.length]= " + move + ";"
            , "     diff += colDiff;"
        );

        result.push(""
            , "     pos= posList[posH[" + movey + "] ^ colMask];"
            , "     posH[" + movey + "] |= " + shl('col', movex2) + ";"
        );

        flip(movex2 + 11, -1, 0);
        flip(movex2 + 12,  1, 0);

        result.push(""
                , "     pos= posList[posV[" + movex + "] ^ colMask];"
                , "     posV[" + movex + "] |= " + shl('col', movey2) + ";"
        );

        flip(movey2 + 11, 0, -1);
        flip(movey2 + 12, 0,  1);

        result.push(""
            , "     pos= posList[posDiag1[" + moveday + "] ^ colMask];"
            , "     posDiag1[" + moveday + "] |= " + shl('col', movedax) + ";"
        );

        flip(movedax + 11, -1, -1);
        flip(movedax + 12,  1,  1);

        result.push(""
            , "     pos= posList[posDiag2[" + movedby + "] ^ colMask];"
            , "     posDiag2[" + movedby + "] |= " + shl('col', movedbx) + ";"
        );

        flip(movedbx + 11, -1,  1);
        flip(movedbx + 12,  1, -1);

        result.push(""
            , "     col= 3 - col;"
            , "     colMask= 65535 - colMask;"
            , "     colDiff= -colDiff;"
            , " }"
        );

        // if (move == 22) { console.log(result.join("\n")); die(); }

        eval("setAt[" + move + "]= (" + result.join("\n") + ");");
    }

    function finished() {
        if (boardLog.length < 4) return true;
        if (boardLog[boardLog.length - 2] == 64 && boardLog[boardLog.length - 1] == 64) return true;
        if (getValidMoves()[0] == 64) {
            swapCol();
            var fin= getValidMoves()[0] == 64;
            swapCol();
            return fin;
        }
        return false;
    }

    function swapCol() {
        col= 3 - col;
        colMask= 65535 - colMask;
        colDiff= -colDiff;
    }
      
    function pass() {
        boardLog[boardLog.length]= 64;
        swapCol();
    }

    // slow! but doesn't matter, not used by computer player
    function undo(count) {
        var flog2= boardLog.concat(); // clone

        initBoard();
        for (var i= 4; i < flog2.length - count; i++) {
            setAt[flog2[i]]();
        }
    }

    // Retrieves the color of a given cell
    function colAtCell(cell) {
        var movey= cell >> 3;
        var movex= cell & 7;
        var result= (posH[movey] >> (movex + movex)) & 3;
        return result == 3 ? 0 : result;
    }
  
    var capPosH= [], capPosV= [], capPosDiag1= [], capPosDiag2= [];
    var capBoardLog= [];

    var capCol, capColMask, capColDiff;
    var capDiff;

    function captureBoard() {

        for (var y= 8; y--; ) {
            capPosH[y]= posH[y];
            capPosV[y]= posV[y];
        }

        for (var y= 15; y--; ) {
            capPosDiag1[y]= posDiag1[y];
            capPosDiag2[y]= posDiag2[y];
        }

        capBoardLog.splice(boardLog.length, 999);
        for (var i= boardLog.length; i--; ) {
            capBoardLog[i]= boardLog[i];
        }
        
        capCol= col;
        capColMask= colMask;
        capColDiff= colDiff;

        capDiff= diff;
    }

    function restoreBoard() {

        for (var y= 8; y--; ) {
            posH[y]= capPosH[y];
            posV[y]= capPosV[y];
        }

        for (var y= 15; y--; ) {
            posDiag1[y]= capPosDiag1[y];
            posDiag2[y]= capPosDiag2[y];
        }

        boardLog.splice(capBoardLog.length, 999);
        for (var i= capBoardLog.length; i--; ) {
            boardLog[i]= capBoardLog[i];
        }
        
        col= capCol;
        colMask= capColMask;
        colDiff= capColDiff;

        diff= capDiff;
    }

    var doMove= function(move, tip, games) {
        if (!tip) {
            setAt[move]();
            refreshBoard();
            markCell(move, 'last-move');
        }
        else {
            updateUI();
            markCell(move, 'tip-move');
        }

        status('Done.'
                // + ' My move is (' + move + ') ' + ((move & 7) + 1) + ',' + ((move >> 3) + 1) + '.'
                + ' My move is ' + ((move & 7) + 1) + '-' + ((move >> 3) + 1) + '.'
                + ' Calculated ' + games + ' games.'
            , 3);
    }

    function computeMoveOld(tip) {
        var moves= unique(getValidMoves());
        if (moves[0] == 64) {
            status('Pass. I can\'t make a move :-(', 3);
            if (!tip) pass();
            refreshBoard();
            return 0;
        }

        var secs= document.getElementById('time').value;
        if (secs < 1) secs= 1;

        var games= 0;
        var gamesPerMove= 0;

//        if (moves.length == 1) {
//            doMove(moves[0], tip, games);
//            return 1;
//        }

        var startTime= new Date().getTime();

        stopCalculating= 0; // FIXME: Hide in function
        endTime= startTime + secs * 1000;

        // Start removing stupid moves from the list of considered moves after 1/3 of the time
        var cleanupTime= startTime + secs * 333;
        
        var scores= [];
/*
        for (var movei in moves) {
            scores[moves[movei]]= 0;
        }
*/
        captureBoard();

        var oppMoves= [];
        var oppScores= [];

        for (var movei in moves) {
            var move= moves[movei];

            setAt[move]();
            oppMoves[movei]= unique(getValidMoves());
            oppScores[movei]= zero64.concat().splice(0, oppMoves[movei].length);
            restoreBoard();
        }

        var dots= '';

        var time;
        var nextMoves;
        var nextMove;
        var move, movei;
        var oppMove, oppMovei;

        updateUI();

        var r= function(v) { var s= '        ' + (Math.round(v * 10) / 10); return s.substr(s.length - 8); };
        var prefix= function(alg, move) { return alg + " " + colName(col) + " " + ('' + (move + 100)).substr(1) + ":  "; };

        var avgScore= function(opps, oppm) {

// console.log(opps); console.log(oppm);

            var min= 999999999;
            var max= -999999999;
            var d= 0;
            var n= oppm ? oppm.length : opps.length;
            for (var i= n; i--; ) {
                var score= oppm ? opps[oppm[i]] : opps[i];
                if (score > max) max= score;
                if (score < min) min= score;
                d += score;
            }

            // returns contains the average score - 30% * (max - min).
            // Now all moves with scores > d can be removed.

            return d / n - (max - min) * 0.3;
        };

        /**
         *  Eliminate useless moves from the queue.
         */
        var reduceMoves= function() {

            var before= moves.length;
            var oppBefore= 0;
            var oppAfter= 0;

            // Reduce moves

            calcMoveScore();
            var d= avgScore(scores, moves);

            var newMoves= [];
            var newOppMoves= [];
            var newOppScores= [];
            for (var movei= moves.length; movei--; ) {
                if (scores[moves[movei]] < d) {
                    console.log("reduceMoves: eliminate " + moves[movei] + ", because " + scores[moves[movei]] + ' < ' + d);
                    continue;
                }
                oppBefore += oppMoves[movei].length;
                newMoves[newMoves.length]= moves[movei];
                newOppMoves[newOppMoves.length]= oppMoves[movei];
                newOppScores[newOppScores.length]= oppScores[movei];
            }
            moves= newMoves;
            oppMoves= newOppMoves;
            oppScores= newOppScores;

            // Reduce oppMoves

            for (var movei in moves) {
                var move= moves[movei];

                var oppm= oppMoves[movei];
                var opps= oppScores[movei];

                var d= avgScore(opps);

                var newOppMove=  [];
                var newOppScore= [];

                for (var oppMovei= oppm.length; oppMovei--; ) {
                    if (opps[oppMovei] < d) continue;
                    newOppMove[newOppMove.length]=   oppm[oppMovei];
                    newOppScore[newOppScore.length]= opps[oppMovei];
                }

                oppAfter += newOppMove.length;

                oppMoves[movei]=  newOppMove;
                oppScores[movei]= newOppScore;
            }

            console.log("reduceMoves: before=" + before + " after=" + moves.length + " oppBefore=" + oppBefore + " oppAfter=" + oppAfter);
        };    

        var calcMoveScoreOppMax= function() {
            scores= [];

            for (var movei in moves) {
                var move= moves[movei];

                var n= oppMoves[movei].length;
                var opps= oppScores[movei];

                var max= -999999;
                for (var oppMovei= n; oppMovei--; ) {
                    if (opps[oppMovei] > max) max= opps[oppMovei];
                }

                scores[move]= -max;

                if (1) {
                    console.log(prefix('OppMax', move) + "max=" + r(max) + " score=" + r(scores[move]));
                }
            }
        };    

        var calcMoveScoreTest1= function() {
            scores= [];

            for (var movei in moves) {
                var move= moves[movei];

                var n= oppMoves[movei].length;
                var opps= oppScores[movei];

                var d= 0;
                for (var oppMovei= n; oppMovei--; ) {
                    d += opps[oppMovei];
                }
                d /= n;

                var dd = 0;
                for (var oppMovei= n; oppMovei--; ) {
                    var score= opps[oppMovei];
                    dd -= score < d ? score : d + Math.pow(score - d, 2);
                }
                scores[move]= dd / n;

                if (1) {
                    console.log(prefix('Test1', move) + " score=" + r(scores[move]));
                }
            }
        };    

        var calcMoveScoreCK= function() {
            scores= [];

            // A3: -17 ...
            // A5: <f>(A3-25)^$A$1</f>
            // K5: <f>(SUM($A5:$G5)^(1/$A$1)*($A3)/COUNT($A3:$G3))</f>

            for (var movei in moves) {
                var move= moves[movei];

                var n= oppMoves[movei].length;
                var opps= oppScores[movei];
                var max= -99999999;
                var sum= 0;

                for (oppMovei= n; oppMovei--; ) {
                    var score= opps[oppMovei];
                    if (score > max) max= score;

                    sum += Math.pow(score - gamesPerMove, 8);
                }

                scores[move]= -Math.floor(Math.pow(sum, 1/8) * max / oppMoves[movei].length);

                console.log(prefix('CK', move) + ' score=' + scores[move]);
            }
        };    

        var calcMoveScore= function() {
            // capCol == 1 ? calcMoveScoreMin() : calcMoveScoreCK();     // Min 10s
            // capCol == 1 ? calcMoveScoreCK() : calcMoveScoreMin();     // Min 10s 17:27
            // capCol == 1 ? calcMoveScoreCK() : calcMoveScoreOppMax();     // Min 10s 17:27
            // calcMoveScoreOppMax();
            // calcMoveScoreOppMax();
            // calcMoveScoreCK();
            calcMoveScoreTest1();
        };

        var inner= function() {

            time= new Date().getTime();

            if (cleanupTime && time > cleanupTime) {
                reduceMoves();
                cleanupTime= Math.max(time + 500, (time + endTime) / 2);
            }

            if (moves.length > 1 && time < endTime) {

                status("Thinking" + dots, 0, 1);
                dots= dots.length > 30 ? '' : dots + '.';

                var nextTime= time + 100;
                while(true) {

                    time= new Date().getTime();
                    if (time > endTime || time > nextTime) break;

                    gamesPerMove++;

                    for (movei in moves) {
                        move= moves[movei];

                        for (oppMovei in oppMoves[movei]) {
                            oppMove= oppMoves[movei][oppMovei];

                            restoreBoard();
                            setAt[move]();

// console.log(oppMoves[move]);
                            setAt[oppMove]();

                            while (1) {
                                nextMoves= getValidMoves();
                                if (nextMoves[0] == 64) {
                                    pass();
                                    nextMoves= getValidMoves();
                                    if (nextMoves[0] == 64) break;
                                }
                                nextMove= nextMoves[Math.floor(Math.random() * nextMoves.length)];
                                setAt[nextMove]();
                            }        

                            if (capCol == 2) {
                                if (diff > 0) oppScores[movei][oppMovei]++;
                                if (diff < 0) oppScores[movei][oppMovei]--;
                            }
                            else {
                                if (diff < 0) oppScores[movei][oppMovei]++;
                                if (diff > 0) oppScores[movei][oppMovei]--;
                            }

                            games++;
                        }

                    }
                }
                setTimeout(inner, 1);
                return;
            }

            restoreBoard();
            endTime= 0;

            calcMoveScore();

            moves.sort(function(a, b) { return scores[b] - scores[a]; });

            // console.log(getValidMoves());

            var s= '';
            for (var movei in moves) {
                s += ' ' + moves[movei] + ':' + (Math.floor(scores[moves[movei]] * 10) / 10);
            }
            console.log("Scores:" + s);
    
            doMove(moves[0], tip, games);
            
            // console.log(scores);
        }

        setTimeout(inner, 10);
        return 1;
    }



    // ====================================================================
    //  UCT
    //  See Sylvain Gelly's Thesis about MoGo
    // ====================================================================





    var inspectRootNode= [];
    var inspectNodes= [];

    function refreshInspector() {

        var indent= '';

        var nodeStr= function(i, i2, node, prefix) {
            var link= "javascript:console.log(_inspectorNode(" + i2 + "))";
            return indent + prefix + "[" + i + ":"
                + " move=<a href=\"" + link + "\">" + node.move + "</a>"
                + (node.prob ? " prob=" + (Math.round((node.prob) * 10000) / 10000) : "")
                + (node.minprob ? " minprob=" + (Math.round(node.minprob * 10000) / 10000) : "")
                + " nb=" + node.nb
                + "]";
        }

        var node= inspectRootNode;
        var html= 'MOVES:<br />';
        indent += "&nbsp;&nbsp;";

        for (var i in inspectNodes) {
            node= node.childNodes[inspectNodes[i]];
            var link= "<a href='javascript:_inspectorSetLevel(" + i + ")'>[-]</a>";
            html += nodeStr(inspectNodes[i], i, node, link + "&nbsp;");
            html += ":<br />";
            indent += "&nbsp;&nbsp;";
        }

        node.childNodes.sort(function(a, b) {
            return (b.minprob || b.prob) - (a.minprob || a.prob);
        });

        for (var j in node.childNodes) {
            var childNode= node.childNodes[j];
            var link= "[+]";
            if (childNode.childNodes && childNode.childNodes.length) {
                link= "<a href='javascript:_inspectorAppend(" + j + ")'>" + link + "</a>";
            }
            html += nodeStr(j, ~j, childNode, link + "&nbsp;");
            html += "<br />";
        }

        document.getElementById("inspector").innerHTML= html;
    }

    function _inspectorChildNode(n) {
        var node= inspectRootNode;
        var i= 0;
        while (n--) node= node.childNodes[inspectNodes[i++]];
        return node;
    }

    function _inspectorNode(n) {
        if (n < 0) {
            return _inspectorChildNode(inspectNodes.length).childNodes[~n];
        }
        return _inspectorChildNode(n + 1);
    }

    function _inspectorSetLevel(n) {
        inspectNodes.splice(n, 9999);
        refreshInspector();
    }

    function _inspectorAppend(n) {
        inspectNodes[inspectNodes.length]= n;
        refreshInspector();
    }

    function inspect(node) {
        inspectRootNode= node;
        inspectNodes= [];
        refreshInspector();
    }






    function computeMoveUCT(tip) {
        var moves= unique(getValidMoves());
        if (moves[0] == 64) {
            status('Pass. I can\'t make a move :-(', 3);
            if (!tip) pass();
            refreshBoard();
            return 0;
        }

        var secs= document.getElementById('time').value;
        if (secs < 1) secs= 1;

        var startTime= new Date().getTime();

        stopCalculating= 0; // FIXME: Hide in function
        endTime= startTime + secs * 1000;

        updateUI();

        var rootNode= {
            // move: 65,       // NOP
            // childNodes: null,
            // validMoves: unique(getValidMoves())
            value: 0,
            nb: 0
        };

        captureBoard();

        function descendByUCB1(node) {
            var childNodes= node.childNodes;
            var i;

            var nb= 0;
            i= childNodes.length;
            while (i--) {
                nb= nb + childNodes[i].nb;
            }

            // Math.log ist ln
            var dividend= 2 * Math.log(nb); //  / Math.log(10);
            // var dividend= Math.log(nb) / 5;

            var maxv= -100000000000;
            var maxi= -1;
            i= childNodes.length;
            while (i--) {
                var childNode= childNodes[i];

                if (childNode.nb == 0) {
                    return childNode;
                }
                
                // Valkyria:
                // winrate := next.Wins/next.Visits;
                // uct := UCTK*Sqrt(ln(n.Visits)/(5*next.Visits));
                // uctvalue := winrate + uct;

                //var v= Math.sqrt(dividend / childNode.nb) - childNode.value / childNode.nb;
                childNode.prob= childNode.value / childNode.nb;
                var v= Math.sqrt(dividend / childNode.nb) + childNode.prob;

                // Anderes Ergebnis! Warum? Und warum laesst sich der Satz des Pythagoras nicht als a + b = c schreiben? :)
                // var v= dividend / childNode.nb + childNode.prob * childNode.prob;

                if (v > maxv) {
                    maxv= v;
                    maxi= i;
                }
            }
            if (maxi < 0) {
                return null;
            }
            return childNodes[maxi];
        }

        function playOneSequence() {

            restoreBoard();
            var nodes= [ rootNode ];
            var nodei = 0;
            while (nodes[nodei].childNodes) {
                var node= descendByUCB1(nodes[nodei]);
                if (node == null) {
                    // this should not happen!
                    // console.warn("No valid child move found!");
                    return false;
                }
                nodes[nodei + 1]= node;
                setAt[nodes[nodei + 1].move]();
                nodei++;
            }

            var node= nodes[nodei];
            var nextMoves= getValidMoves();

            var uniqueNextMoves= unique(nextMoves);

            // Hopefully fast, have to check
            node.childNodes= Array(uniqueNextMoves.length);
            for (var i in uniqueNextMoves) {
                node.childNodes[i]= {
                    move: uniqueNextMoves[i],
                    // childNodes: null,
                    // validMoves: nextMoves0,
                    value: 0,
                    nb: 0,
                };
            }

            // var xx= 0;

            // Play random game
            while (true) {

                // if (xx++ > 300) {
                //     console.warn("Break in Random Game after 300 loops");
                //     break;
                // }

                if (nextMoves[0] == 64) {
                    pass();
                    nextMoves= getValidMoves();
                    if (nextMoves[0] == 64) break;
                }
                var nextMove= nextMoves[Math.floor(Math.random() * nextMoves.length)];
                setAt[nextMove]();
                nextMoves= getValidMoves();
            }

            // richtig!
            var value= (diff > 0 ? 1 : 0) ^ ((capCol + nodei) & 1);

            node.prob= node.value= value;
            node.nb= 1;
            

            // Update values
            while (nodei--) {
                value= 1 - value;
                nodes[nodei].value += value;
                nodes[nodei].nb++;
                nodes[nodei].prob= nodes[nodei].value / nodes[nodei].nb;
            }
            return true;
        }

        var games= 0;
        var ngames= 8000;

        var inner= function() {

            status("To go: " + ngames, 0, 1);

            for (var i= 0; i < 100 && ngames > 0; i++) {
                playOneSequence();
                ngames--;
            }

            if (ngames && !stopping()) {
                setTimeout(inner, 1);
                return;
            }

            var resultNode= null;
            var minprob= 0;
            for (var i= rootNode.childNodes.length; i--; ) {

                var childNode= rootNode.childNodes[i];

                // find child's child (that's our opponent's turn) with highest probability to win
                var maxprob= childNode.childNodes ? childNode.childNodes[0].prob : (childNode.value / childNode.nb);
                for (var j= childNode.childNodes.length; j-- > 1; ) {
                    if (maxprob < childNode.childNodes[j].prob) {
                        maxprob= childNode.childNodes[j].prob;
                    }
                }

                // our probability to win is 1 - the highest prob. to win for our opponent (supposed to draw clever)
                childNode.minprob= 1 - maxprob;

                console.warn("Move: " + childNode.move + " Prob:" + childNode.prob + " MinProb:" + childNode.minprob);
                console.log(childNode);

                // let's try the move, where our opponents best choice is the lowest
                if (minprob < childNode.minprob) {
                    resultNode= childNode;
                    minprob= childNode.minprob;
                }
            }

            console.warn("I'll make Move: " + resultNode.move + " Prob:" + resultNode.prob + " MinChildProb:" + resultNode.minprob);

            // var resultNode= descendByUCB1(rootNode);
            // playOneSequence();

            restoreBoard();
            endTime= 0;

            doMove(resultNode.move, tip, games);

            inspect(rootNode);
        };

        setTimeout(inner, 1);

    }

    function computeMove(tip) {
        if (col == 1) return computeMoveUCT(tip);
        return computeMoveOld(tip);
    }

    // ====================================================================
    //  Output
    // ====================================================================

    // See: http://de.wikipedia.org/wiki/Benutzer:Buncic/Unicode/Geometrische_Formen
    function stone(col) {
        return ' \u25CB\u25CF '.substr(col & 3, 1);
    }

    function stoneBg(col) {
        return ' \u25CF  '.substr(col & 3, 1);
    }

    function colName(col) {
        if (col == 1) return "White";
        if (col == 2) return "Black";
        return "?"
    }

    function defaultStatus() {
        clearTimeout(hStatusTimer);
        hStatusTimer= null;
        var status= finished() ? 'wins' : 'leads';
        if (diff > 0) {
            status= 'White ' + status + ' by ' + diff + ' points';
        }
        else if (diff < 0) {
            status= 'Black ' + status + ' by ' + (-diff) + ' points';
        }
        else {
            status= finished() ? 'it\'s a draw' : 'The game is even';
        }
        if (finished()) {
            status= 'Game over, ' + status + '!';
        }
        else {
            status= colName(col) + '\'s turn. ' + status + '.';
        }
        console.log(status);
        document.getElementById('status').innerHTML= status;
    }

    function status(html, secs, noConsole) {
        if (!noConsole) console.log('STATUS: ' + html);
        document.getElementById('status').innerHTML= html;
        if (hStatusTimer) {
            clearTimeout(hStatusTimer);
            hStatusTimer= null;
        }
        if (secs) {
            hStatusTimer= setTimeout(defaultStatus, secs * 1000);
        }
    }

    function printBoard() {

        var html= '<table cellspacing="0" cellpadding="0">';
        var i= 0;
        for (var y= 0; y < 8; y++) {
            html += '<tr>';
            for (var x= 0; x < 8; x++, i++) {
                html += '<td onclick="clickCell(' + i + ')" id="cell' + i + '"><div class="cell"></div></td>';
            }
            html += '</tr>';
        }
        html += '</table>';
        document.getElementById('board').innerHTML= html;
    }

    function refreshBoard() {
        var i= 0;
        for (var y= 0; y < 8; y++) {
            var pos= posH[y];
            for (var x= 0; x < 8; x++) {
                (document.getElementById('cell' + i) || {}).innerHTML=
                      '<div class="cell">'
                    +   '<div class="num debug">' + i + '</div>'
                    +   '<div class="stone-bg">' + stoneBg(pos) + '</div>'
                    +   '<div class="stone-fg">' + stone(pos) + '</div>'
                    + '</div>'
                pos >>= 2;
                i++;
            }
        }
        var cells= finished() ? [] : getValidMoves();

        unmarkAllCells();
        for (var i in cells) markCell(cells[i], 'valid-move-' + col);

        updateUI();
    }

    function unmarkAllCells() {
        for (var i= 0; i < 64; i++) {
            (document.getElementById('cell' + i) || {}).className= '';
        }
    }

    function markCell(cell, class_) {
         (document.getElementById('cell' + cell) || {}).className= class_;
    }

    // ====================================================================
    //  Debugging
    // ====================================================================

    function pldump(pos) {

        var newpos= pos;
        var i= 8;
        var result= '';
        while (i--) {
            result += '.OX,'.substr((newpos ^ colMask) & 3, 1);
            newpos >>= 2;
        }
        return result + ' ' + pos;
    }

    function clickDump(posXName) {
        if (posXName == 'sit') {
            var s= '';
            for (var i= 4; i < boardLog.length; i++) {
                s += 'setAt[' + boardLog[i] + '](); ';
                if (i & 1) s += ' ';
            }
            console.log(s);
            return;
        }
        if (posXName == 'validMoves') {
            console.log(getValidMoves());
            return
        }
        var posX;
        if (posXName == 'posH') posX= posH;
        if (posXName == 'posV') posX= posV;
        if (posXName == 'posDiag1') posX= posDiag1;
        if (posXName == 'posDiag2') posX= posDiag2;
        console.log('============= ' + posXName + ' =============');
        for (var i= 0; i < posX.length; i++) {
            console.log(pldump(posX[i] ^ colMask));
        }
    }

    // ====================================================================
    //  UI
    // ====================================================================

    function computing() {
        if (!initPosListDone) {
            status("Please wait until the game is ready!");
            return true;
        }
        if (endTime) {
            status("Please wait until the computer has made it's move!", 0, true);
            return true;
        }
        return false;
    }

    function stopping() {
        return stopCalculating;
    }

    function setComputerCol(newCol) {
        if (computerCol == 3) {
            oldComputerCol= newCol;
            return;
        }
        computerCol= newCol;
    }

    function updateUI() {
        var begun= boardLog.length > 4;
        var is_finished= finished();
        var computing= endTime;
        
        var up= function(button, on) {
            document.getElementById('button_' + button).className= on ? 'button' : 'button_off';
        };
        
        // <a id="button_new_game" class="button" href="javascript:clickNewGame();">New</a>
        up("new_game",  !computing && begun);
        up("undo",      !computing && begun);
        up("pass",      !computing && !is_finished);
        up("tip",       !computing && !is_finished);
        up("stop",      computing);
        up("settings",  true);
    }

    function clickCell(move) {
        if (computing() || finished()) return;
        
        if (colAtCell(move)) {
            status("Cell is already taken!", 3);
            return;
        }

        var moves= unique(getValidMoves());
        var ok= 0;
        for (var movei in moves) {
            if (moves[movei] == move) { ok= 1; break; }
        }
        if (!ok) {
            status("Not a valid move!", 2);
            return;
        }

        setAt[move]();
        refreshBoard();
        defaultStatus();
        markCell(move, 'last-move');

        if (computerCol & col) {
            computeMove();
        }
    }

    function clickNewGame() {
        if (computing() || boardLog.length <= 4) return;

        initBoard();
        refreshBoard();
        defaultStatus();

        if (computerCol & col) {
            computeMove();
        }
    }

    function clickUndo() {
        if (computing()) return;
        if (boardLog.length <= 4) {
            console.log("CAN'T UNDO");
            return;
        }

        undo(computerCol == 1 || computerCol == 2 ? 2 : 1);
        refreshBoard();
        defaultStatus();
        if (boardLog.length > 4) {
            if (boardLog[boardLog.length - 1] != 64) {
                markCell(boardLog[boardLog.length - 1], 'last-move');
            }
            else {
                status(colName(3 - col) + " passed.", 2);
            }
        }
    }

    function clickPass() {
        if (computing() || finished()) return;

        pass();
        refreshBoard();
        defaultStatus();

        if (computerCol & col) {
            computeMove();
        }
    }

    function clickTip() {
        if (computing() || finished()) return;

        refreshBoard();
        computeMove(1);
    }

    function clickStop() {
        if (!initPosListDone || !computing()) return;
        
        status("Stopping computation. Please hold on...");
        endTime= 1;
        stopCalculating= 1;
    }
    
    function clickSettings() {
        if (!initPosListDone) return;

        // document.getElementById('computer_col_0').enabled= computerCol != 3;
        // document.getElementById('computer_col_1').enabled= computerCol != 3;
        // document.getElementById('computer_col_2').enabled= computerCol != 3;
        document.getElementById('computer_col_' + (computerCol == 3 ? oldComputerCol : computerCol)).checked= 1;
        document.getElementById('settings').style.display= 'block';
    }

    function clickCloseSettings() {
        document.getElementById('settings').style.display= 'none';
        if (!computing() && (computerCol & col)) {
            computeMove();
        }
    }

    function clickAuto() {
        oldComputerCol= computerCol;
        computerCol= 3;

        stopCalculating= 0;

        var score= [0, 0];
        document.getElementById('button_auto').innerHTML= score.join(':');
        // aAuto.html.split(':');

        var wait= function() {
            if (!computing()) {
                if (!computeMove() && !computeMove()) {
                    computerCol= oldComputerCol;
                    console.log("GAME IS OVER");
                    defaultStatus();

                    score[diff > 0 ? 0 : 1]++;
                    document.getElementById('button_auto').innerHTML= score.join(':');

                    if (stopping()) return;

                    initBoard();
                }
            }
            if (!stopping()) setTimeout(wait, 500);
        }
        wait();
    }

    function doOnload() {

        status("Initializing, please hold on a second...");

        zero64= [];
        for (var i= 64; i--; ) zero64[i]= 0;

        initCellScore();
        makeGetValidMoves();
        printBoard();

        setAt= []
        for (var i= 64; i--; ) makeSetAt(i);
        setAt[64]= pass;
        setAt[65]= function() {}; // NOP
        
        initPosList();

        var ready= function() {
            if (!initPosListDone) {
                setTimeout(ready, 100);
                return;
            }
            initBoard();


            // seltsamer move von weiss
            // setAt[26](); setAt[34](); setAt[41](); setAt[18](); setAt[42](); setAt[25](); setAt[20](); setAt[33](); setAt[44](); setAt[53](); setAt[32](); setAt[40](); setAt[11](); setAt[10](); setAt[2](); setAt[17](); setAt[16](); setAt[24](); setAt[48]();
            // setAt[8](); setAt[0](); setAt[51](); setAt[19](); setAt[49](); setAt[50](); setAt[12](); setAt[21](); setAt[9](); setAt[5](); setAt[4](); setAt[60](); setAt[58](); setAt[29](); setAt[13](); setAt[6](); setAt[7](); setAt[3](); setAt[1](); setAt[59](); setAt[57](); setAt[43](); setAt[45](); setAt[37](); setAt[52](); setAt[61](); setAt[38](); setAt[31](); setAt[39](); setAt[56](); setAt[22](); setAt[47]();
            // setAt[62](); setAt[63](); setAt[30](); setAt[46]();
            // setAt[54](); setAt[55](); setAt[64](); setAt[14](); setAt[23](); setAt[15](); setAt[64](); 

            // setAt[44](); setAt[45](); setAt[19](); setAt[43](); setAt[37](); setAt[29](); setAt[30](); setAt[22](); setAt[38](); setAt[46](); setAt[21](); setAt[12](); setAt[5](); setAt[3](); setAt[13](); setAt[4](); setAt[2](); setAt[26](); setAt[42](); setAt[41](); setAt[20](); setAt[11](); setAt[10](); setAt[18](); setAt[34](); setAt[17](); setAt[6]();

            // setAt[44](); setAt[45](); setAt[19](); setAt[43](); setAt[37](); setAt[29](); setAt[30](); setAt[22](); setAt[38](); setAt[46](); setAt[21](); setAt[12](); setAt[5](); setAt[3](); setAt[13](); setAt[4](); setAt[2](); setAt[26](); setAt[42](); setAt[41](); setAt[20](); setAt[11](); setAt[10](); setAt[18](); setAt[34](); setAt[17](); setAt[6](); setAt[9](); setAt[23](); setAt[31](); setAt[25](); setAt[24](); setAt[47](); setAt[33](); setAt[40](); setAt[53](); setAt[61](); setAt[50](); setAt[58](); setAt[55]();
            // setAt[51](); setAt[60](); setAt[59](); setAt[15](); setAt[62](); setAt[48](); setAt[0](); setAt[32](); setAt[63](); setAt[52](); setAt[1](); setAt[57](); setAt[16](); setAt[8](); setAt[56](); setAt[54](); setAt[39](); setAt[14](); setAt[7](); setAt[64](); setAt[49](); setAt[64](); 
			// setAt[44](); setAt[43](); setAt[42](); setAt[45](); setAt[29](); setAt[51](); setAt[34](); setAt[37](); setAt[19](); setAt[26](); setAt[38](); setAt[20](); setAt[46](); setAt[52](); setAt[58](); setAt[53](); setAt[61](); setAt[12](); setAt[4](); setAt[21](); setAt[13](); setAt[60](); setAt[10](); setAt[62](); setAt[25](); 
            // setAt[19](); setAt[18](); setAt[44](); setAt[29](); setAt[21](); setAt[45](); setAt[37](); setAt[13](); setAt[26](); setAt[25](); setAt[20](); setAt[42](); setAt[34](); setAt[12](); setAt[11](); setAt[51](); setAt[4]();
            // setAt[19](); setAt[18](); setAt[44](); setAt[29](); setAt[21](); setAt[45](); setAt[37](); setAt[13](); setAt[26](); setAt[25](); setAt[20](); setAt[42](); setAt[34](); setAt[12](); setAt[11](); setAt[51](); setAt[4](); setAt[3](); setAt[2](); setAt[41](); setAt[5](); setAt[43](); setAt[22]();
            // setAt[19](); setAt[18](); setAt[44](); setAt[29](); setAt[21](); setAt[45](); setAt[37](); setAt[13](); setAt[26](); setAt[25](); setAt[20](); setAt[42](); setAt[34](); setAt[12](); setAt[11](); setAt[51](); setAt[4](); setAt[3](); setAt[2](); setAt[41](); setAt[5](); setAt[43](); setAt[22](); setAt[14](); setAt[52](); setAt[61](); setAt[7](); setAt[53](); setAt[46](); setAt[39](); setAt[59](); setAt[38](); setAt[30](); setAt[10](); setAt[24](); setAt[16](); setAt[8](); setAt[23](); setAt[31](); setAt[17](); setAt[15](); setAt[47](); setAt[55](); setAt[58](); setAt[57](); setAt[6](); setAt[32](); setAt[50](); setAt[40](); setAt[60](); setAt[62](); setAt[33](); setAt[49]();
            setAt[19](); setAt[18](); setAt[44](); setAt[29](); setAt[21](); setAt[45](); setAt[37](); setAt[13](); setAt[26](); setAt[25](); setAt[20](); setAt[42](); setAt[34](); setAt[12](); setAt[11](); setAt[51](); setAt[4](); setAt[3](); setAt[2](); setAt[41](); setAt[5](); setAt[43](); setAt[22](); setAt[10](); setAt[59](); setAt[52](); setAt[50](); setAt[17](); setAt[16]();
            // setAt[19](); setAt[18](); setAt[44](); setAt[29](); setAt[21](); setAt[45](); setAt[37](); setAt[13](); setAt[26](); setAt[25](); setAt[20](); setAt[42](); setAt[34](); setAt[12](); setAt[11](); setAt[51](); setAt[4](); setAt[3](); setAt[2](); setAt[41](); setAt[5](); setAt[43](); setAt[22](); setAt[14](); setAt[52](); setAt[61](); setAt[7](); setAt[53](); setAt[46](); setAt[39](); setAt[59](); setAt[38](); setAt[30](); setAt[10](); setAt[24](); setAt[16](); setAt[8](); setAt[23](); setAt[31](); setAt[17](); setAt[15](); setAt[47](); setAt[55](); setAt[58](); setAt[57](); setAt[6](); setAt[32](); setAt[50](); setAt[40](); setAt[60](); setAt[62](); setAt[33](); setAt[49](); setAt[56](); setAt[9]();

            refreshBoard();
            defaultStatus();
        }
        setTimeout(ready, 100);
    }

</script>
<style>
    body {
        font-family: Tahoma, sans-serif;
        height: 100.1%;
        border: 0;
        margin: 0;
    }
    #head {
        background-color: black;        
        padding: 10px 10px ;
        margin: 0 0 8px 0;
        color: #FFF;
        text-align: right;
    }
    #head h1 {
        float: left;
        text-weight: bold;
        font-size: 100%;
        padding: 0;
        margin: 0;
        color: #F2D4C0;
    }
    #head a {
        color: #FFF;
    }
    #body {
        padding: 10px;
    }
    #settings {
        position: relative;
        z-index: 1;
        display: none;
    }
    #settings .container {
        position: absolute;
        top: 1em;
        left: 1em;
        width: 300px;
        border: 1px solid black;
        background-color: #FFF;
        padding: 10px;
    }
    #settings .p {
        display: block;
        padding: 0.4em;
    }
    #settings .p .title {
        padding-top: 0.6em;
        border-bottom: 3px solid #988579;
    }
    #settings .right {
        text-align: right;
    }
    #board table {
        border-collapse: collapse;
        border: solid 6px #988579;
        background-color: #DABFAD;
    }
    #board table tr {
        vertical-align: top;
    }
    #board table td {
        border: solid 3px #B8A192;
        text-align: center;
        cursor: pointer;
    }
    #board .cell {
        position: relative;
        overflow: hidden;
        width: 40px;
        height: 40px;
    }
    #board .cell div {
        width: 40px;
        text-align: center;
        position: absolute;
        margin: 0;
        padding: 0;
    }
    #board .cell .num {
        font-size: 8px;
        color: #FFF;
    }
    #board .cell .stone-bg, #board .cell .stone-fg {
        top: -15px;
        font-size: 300%;
    }
    #board .cell .stone-bg {
        color: #fff;
    }
    #board .valid-move-1 {
        background-color: #F2D4C0;  /* whitish */
    }
    #board .valid-move-2 {
        background-color: #A79285;  /* blackish */
    }
    /* red: E55252 yellow: E5E052 */
    #board .last-move {
        background-color: #52C1E5;  /* blue */
    }
    #board .tip-move {
        background-color: #52E574;  /* green */
    }
    #status_outer {
        overflow: hidden;
        margin: 16px 0 10px 0;
    }
    #status {
        width: 1000px;
    }
    #console {
        padding: 20px;
        margin: 20px;
        border: 1px solid #888;
    }
    .button, .button_off {
        -moz-border-radius: 6px;
        -webkit-border-radius: 6px;
        padding: 4px 8px;
        margin-right: 4px;
        border: solid 2px #000;
        background-color: #EEE;
        text-decoration: none;
        color: #000;
    }
    .button_off {
        color: #CCC;
        border-color: #444;
    }
    .button:hover {
        background-color: #DDD;
    }
    #inspector {
        position: absolute;
        top: 8em;
        left: 25em;
        width: 500px;
        height: auto;
        border: 1px solid #666;
        margin: 5px;
        padding: 5px;
    }
    .debug {
        x-display: none;
    }
</style>
</head>
<body onload="doOnload()">
    <div id="head">
        <h1>MoThello</h1>
        <small>(c) 2008 by Dietrich Raisin, info@raisin.de, <a href="http://www.raisin.de/">www.raisin.de</a></small>
    </div>
    <div id="body">
        <div>
            <table cellspacing="0" cellpadding="0"><tr>
                <td><a id="button_new_game" class="button_off" href="javascript:clickNewGame();">New</a></td>
                <td><a id="button_undo"     class="button_off" href="javascript:clickUndo();">Undo</a></td>
                <td><a id="button_pass"     class="button_off" href="javascript:clickPass();">Pass</a></td>
                <td><a id="button_tip"      class="button_off" href="javascript:clickTip();">Tip</a></td>
                <td><a id="button_stop"     class="button_off" href="javascript:clickStop();">Stop</a></td>
                <td><a id="button_settings" class="button_off" href="javascript:clickSettings();">Settings</a></td>
            </tr></table>
        
            <span class="debug">
                <a class="button" href="javascript:clickDump('posH');">posH</a>
                <a class="button" href="javascript:clickDump('posV');">posV</a>
                <a class="button" href="javascript:clickDump('posDiag1');">posDiag1</a>
                <a class="button" href="javascript:clickDump('posDiag2');">posDiag2</a>
                <a class="button" href="javascript:clickDump('validMoves');">validMoves</a>
                <a class="button" href="javascript:clickDump('sit');">Sit</a>
                <a id="button_auto" class="button" href="javascript:clickAuto();">Auto</a>
            </span>
        </div>
        <span id="settings"><span class="container">
            <span class="p"><span class="title">Computer player</span></span>
            <span class="p">
                <input type="radio" name="computer_col" id="computer_col_0" onclick="setComputerCol(0)">None
                <input type="radio" name="computer_col" id="computer_col_2" onclick="setComputerCol(2)">Black
                <input type="radio" name="computer_col" id="computer_col_1" onclick="setComputerCol(1)">White
            </span>
            <span class="p"><span class="title">Calculation Time</span></span>
            <span class="p">Limit to <input id="time" maxlength="3" size="2" value="8"> seconds</span>
            <span class="p right"><a class="button" href="javascript:clickCloseSettings();">Close</a></span>
        </span></span>
        <div id="status_outer"><div id="status">&nbsp;</div></div>
        <div id="board"></div>
        <div id="console" class="debug"></div>
        <div id="inspector" class="debug"></div>
    </div>
</body>
