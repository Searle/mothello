<head>
<title>MoThello</title>
<script>

    // ====================================================================
    //  MoThello Version 2008-08-20. Inspired by MoGo.
    //  (c) 2008 by Dietrich Raisin, info1@raisin.de, www.raisin.de
    //
    //  Released under the Artistic License 2.0. Here are the terms:
    //  http://www.opensource.org/licenses/artistic-license-2.0.php
    //
    //  To make a copy, this file is the only one you need. No images were
    //  used, the stones are unicode characters.
    //
    //  Lessons learned:
    //  - Hashes are slow
    //  - Function calls are slow
    //  - Generating new arrays is slow
    // ====================================================================

    if (typeof console == 'undefined') {

        // Firebug Feather :-)
        console= {
            log: function(value) {
                var lines= document.getElementById('console').innerHTML.split('<br>');
                lines.push(value);
                while (lines.length > 15) lines.shift();
                document.getElementById('console').innerHTML= lines.join('<br>');
            }
        };
    }

    var boardLog;               // Log of the moves made

    var posH;                   // Board from a horizontal point of view
    var posV;                   // Board from a vertical point of view
    var posDiag1;               // Board from a diagonal point of view
    var posDiag2;               // Board from the other diagonal point of view

    var col;                    // Current player's color. 1 (white) or 2 (black).
    var colMask;                // 0 if col == 1, or 0xFFFF if col == 2
    var colDiff;                // 1 if col == 1, or -1 if col == 2
    
    var diff;                   // Current score (if positive, points that white is ahead, otherwise -points that black is ahead)

    var posList;                // See initPosList
    var initPosListDone;
    
    var undefined= undefined;   // jQuery does that. So it's correct. qed.

    var getValidMoves;          // Function generated by makeGetValidMoves()
    var validMovesCheck;        // Flag indicating if the board is already initialized
    var validMoves;

/*
    var recalcValidHV;
    var recalcValidDiag;
    var validHV;
    var validDiag;
    var validMoves;
*/

    var hStatusTimer= null;     // Used by status(). Timer for switching back the status information to default value

    var endTime= 0;             // Used by computeMove()

    var cellScore;

    var setAt;

    var computerCol= 1;

    // ====================================================================
    //  Core
    // ====================================================================

    function initCellScore() {
        cellScore= [];
        for (var i= 0; i < 64; i++) {
            cellScore[i]= 2;
        }
        for (var i= 0; i < 8; i++) {
            cellScore[i] += 2;
            cellScore[i * 8] += 2;
            cellScore[i + 56] += 2;
            cellScore[i * 8 + 7] += 2;
        }
        for (var i= 2; i < 6; i++) {
            cellScore[i + 16]++;
            cellScore[i * 8 + 2]++;
            cellScore[i + 40]++;
            cellScore[i * 8 + 5]++;
        }
        cellScore[9]= cellScore[14]= cellScore[49]= cellScore[54]= 1;
    }

    function initBoard() {
        posH= [];
        posV= [];
        posDiag1= [];
        posDiag2= [];
        
        for (var y= 8; y--; ) {
            posH.push(0);
            posV.push(0);
        }

        for (var y= 15; y--; ) {
            posDiag1.push(0);
            posDiag2.push(0);
        }

        boardLog= [];

        // Black begins
        col= 2;
        colMask= 65535;
        colDiff= -1;
        
        diff= 0;
/*
        recalcValidHV= 0;
        recalcValidDiag= 0;
        validHV= validMovesCheck.concat();
        validDiag= validMovesCheck.concat();
        validMoves= [];
*/

        validMoves= [];

        setAt[28]();
        setAt[27]();
        setAt[35]();
        setAt[36]();

        // setAt[29](); setAt[37](); setAt[45](); setAt[38](); setAt[42](); setAt[22]();

        status("Let's go!", 1);
    }

    //  The entries for all possible positions for one row are stored in the
    //  posList array. The index consists of 2 * 8 bits for the 8 cells. 2 bits
    //  are used as follows: 0= empty, 1=white, 2=black, 3=empty.
    //
    //  The entries can be used for either opponent. One of the opponent
    //  looks up posList[n], the other posList[n ^ 0xffff].
    //
    //  Each entry looks like this:
    //  [ valid2, valid1, valid0,
    //      newpos0, newpos1, ... , newpos7,
    //      flipped0-left, flipped0-right, flipped1-left, flipped1-right, ... , flipped7-left, flipped7-right,
    //  ]
    //
    //  validN      0..  Valid moves for white in that position.
    //
    //  newposN     3..  New position if white's move is N.
    //              The new position includes the flipped captures stones if there are any.
    //
    //  flippedN    11.. Number of flipped stones to the left and to the right if white's move is N.
    //
    //  // set1N       27.. DOCME
    //
    //  // set2N       35.. DOCME
    //
    function initPosList() {
    
        initPosListDone= 0;
        posList= new Array(65536);

        var pos0= 0;

        var nextChunk= function() {

            var pos,
                had, had1pos,
                want1, want2, wantpos,
                j,
                valid,
                newpos, flipped; // , set1, set2;

            for (chunk= 8192; chunk--; pos0++) {
    
                pos= pos0;
                had= want1= want2= 0;
                had1pos= wantpos= -1;
                valid= [ 9, 9, 9 ];
                newpos= [ pos0, pos0, pos0, pos0, pos0, pos0, pos0, pos0 ];
                flipped= [ 0, 0,  0, 0,  0, 0,  0, 0,  0, 0,  0, 0,  0, 0,  0, 0 ];
                validi= 0;
    
                for (j= 0; j < 8; j++) {

                    if ((pos & 3) == 1) {
                        if (wantpos >= 0) {
                            if (want2) {
                                valid[validi++]= wantpos;
                                
                                // Flip captured stones
                                newpos[wantpos] ^=
                                    ~(-1 << (j + j - wantpos - wantpos - 2))
                                    << (wantpos + wantpos + 2);
                                flipped[wantpos + wantpos + 1]= j - wantpos -1;
                            }
                            wantpos= -1;
                        }
                        had= 1;
                        want2= 0;
                        newpos[j]= undefined;
                    }
                    else if ((pos & 3) == 2) {
                        if (had == 1) {
                            had= 2;
                            had1pos= j;
                        }
                        want2= 1;
                        newpos[j]= undefined;
                    }
                    else {
                        if (had == 2) {
                            valid[validi++]= j;

                            // Flip captured stones
                            newpos[j] ^=
                                ~(-1 << (j + j - had1pos - had1pos))
                                << (had1pos + had1pos);
                            flipped[j + j]= j - had1pos;
                        }
                        wantpos= j;
                        had= want1= want2= 0;

                        newpos[j]= newpos[j] & ~(3 << (j + j)) | (1 << (j + j));
                    }

                    pos >>= 2;
                }

                // Additionally to it's purpose of concating, "concat" clones the array, which is
                // what we need here.
                posList[pos0]= valid.sort().concat(newpos).concat(flipped); // .concat(set1).concat(set2);

                // console.log(valid);
            }
            if (pos0 < 65536) {
                setTimeout(nextChunk, 1);
                return;
            }
            initPosListDone= 1;
            console.log("initPosList DONE");
        }
        setTimeout(nextChunk, 1);
    }

    // Builds an optimized function that calculates the valid moves.
    // The resulting function is fast, but still contains to many loops
    // and ifs, so I'm not very happy about it yet.
    // It's pretty much the bootleneck of the whole computaion.
    // At least that's what Firebug says.
    //
    function makeGetValidMoves1() {

        var result= [];

        result.push(""
            , " function() {"
            , "     var check= {};"     // HASH???
            , "     var pos, cell;"
        );

        var checkValid= function(posArray, move, base, mul, len) {

            result.push(""
                , "     pos= posList[" + posArray + "[" + move + "] ^ colMask];"
            );

            if (mul == -1) mul= ' - ';
            else if (mul == 1) mul= (base ? ' + ' : '');
            else if (mul > 0) mul= (base ? ' + ' : '') + mul + ' * ';
            else mul= (base ? ' - ' : ' -') + -mul + ' * ';

            if (base == 0) base= '';

            for (var i= 0; i < 3; i++) {
                var cell= base + mul + "pos[" + i + "]"
                result.push(""
                    , "     if (pos[" + i + "] < " + len + ") {"
                    , "         check[" + cell + "]= 1;"
                );
            };
            result.push(""
                , "     }}}"
            );
        }

        for (var i= 0; i < 8; i++) {
            checkValid('posH',      i, i * 8, 1, 8);
            checkValid('posV',      i, i,     8, 8);
        }
        for (var i= 2; i < 8; i++) {
            checkValid('posDiag1',  i, 7 - i, 9,  i + 1);
            checkValid('posDiag2',  i, i * 8, -7, i + 1);
        }
        for (var i= 8; i < 13; i++) {
            checkValid('posDiag1',  i, (i - 7) * 8, 9,  15 - i);
            checkValid('posDiag2',  i, 49 + i,      -7, 15 - i);
        }

        result.push(""
            , "     var result= [];"

            , "     for (var cell in check) {"
            , "         cell= parseInt(cell);"
            , "         var score= cellScore[cell];"
            , "         while (score--) result[result.length]= cell;"
            , "     }"

            , "     return result;"
            , " }"
        );

        console.log(result.join("\n"));

        eval("getValidMoves= (" + result.join('') + ");");
    }

    function makeGetValidMoves() {

        var result= [];

        result.push(""
            , " function() {"
//            , "     var check= validMovesCheck.concat();"
            , "     var cellScore2= cellScore.concat();"
            , "     var valid, cell, score;"
            , "     var result= [];"
        );

        var checkValid= function(posArray, move, base, mul, len) {

            result.push(""
                , "     valid= posList[" + posArray + "[" + move + "] ^ colMask];"
            );

            if (mul == -1) mul= ' - ';
            else if (mul == 1) mul= (base ? ' + ' : '');
            else if (mul > 0) mul= (base ? ' + ' : '') + mul + ' * ';
            else mul= (base ? ' - ' : ' -') + -mul + ' * ';

            if (base == 0) base= '';

            for (var i= 0; i < 3; i++) {
                result.push(""
                    , "     if (valid[" + i + "] < " + len + ") {"
//                    , "         cell= " + base + mul + "valid[" + i + "];"

//                    , "         if (score= cellScore2[cell]) {"
                    , "         if (score= cellScore2[" + base + mul + "valid[" + i + "]]) {"
                    , "             cell= " + base + mul + "valid[" + i + "];"
                    , "             cellScore2[cell]= 0;"
                    , "             while (score--) result[result.length]= cell;"


/*
                    , "         if (check[cell] == 0) {"
                    , "             check[cell]= 1;"
                    , "             score= cellScore[cell];"
                    , "             while (score--) result[result.length]= cell;"
*/
/*
                    , "             result[result.length]= cell;"
                    , "             if (score >= 2) { result[result.length]= cell;"
                    , "                 if (score >= 3) { result[result.length]= cell;"
                    , "                     if (score >= 4) { result[result.length]= cell;"
                    , "                         if (score >= 6) { result[result.length]= cell; result[result.length]= cell;"
                    , "             }}}}"
*/
                    , "         }"
                );
            };
            result.push(""
                , "     }}}"
            );
        }

        for (var i= 0; i < 8; i++) {
            checkValid('posH',      i, i * 8, 1, 8);
            checkValid('posV',      i, i,     8, 8);
        }
        for (var i= 2; i < 8; i++) {
            checkValid('posDiag1',  i, 7 - i, 9,  i + 1);
            checkValid('posDiag2',  i, i * 8, -7, i + 1);
        }
        for (var i= 8; i < 13; i++) {
            checkValid('posDiag1',  i, (i - 7) * 8, 9,  15 - i);
            checkValid('posDiag2',  i, 49 + i,      -7, 15 - i);
        }

        result.push(""
            , "     return result;"
            , " }"
        );

        console.log(result.join("\n"));

        eval("getValidMoves= (" + result.join('') + ");");
    }


    function makeGetValidMoves2() {

        var result= [];

        var checkValid= function(posArray, recalcVar, recalcBit, move, base, mul, len) {

            // result[result.length] is faster than result.push, according to the net

            result.push(""
                , "     if (recalcValid" + recalcVar + " & " + (1 << recalcBit) + ") {"

, "         console.log('recalcing: " + recalcVar + ", " + recalcBit + "');"

                , "         pos= posList[" + posArray + "[" + move + "] ^ colMask];"
            );

            if (mul == -1) mul= ' - ';
            else if (mul == 1) mul= (base ? ' + ' : '');
            else if (mul > 0) mul= (base ? ' + ' : '') + mul + ' * ';
            else mul= (base ? ' - ' : ' -') + -mul + ' * ';

            if (base == 0) base= '';

            for (var i= 0; i < 3; i++) {
                var cell= base + mul + "pos[" + i + "]"
                result.push(""
                    , "         if (pos[" + i + "] < " + len + ") {"
                    , "             valid" + recalcVar + "[" + cell + "] |= " + (1 << recalcBit) + ";"
                );
            };
            result.push(""
                , "         }}}"
                , "     }"
            );
        }

        result.push(""
            , " function() {"
            , "     if (recalcValidHV == 0 && recalcValidDiag == 0) {"
            , "         return validMoves;"
            , "     }"

, "         console.log('=====================');"

            , "     var pos, cell;"
            , "     var result= [];"

            , "     cell= 64;"
            , "     while (cell--) {"
            , "         validHV[cell] &= ~recalcValidHV;"
            , "         validDiag[cell] &= ~recalcValidDiag;"
            , "     }"
        );

        for (var i= 0; i < 8; i++) {
            checkValid('posH',      'HV',   i,      i, i * 8, 1, 8);
            checkValid('posV',      'HV',   i + 16, i, i,     8, 8);
        }
        for (var i= 2; i < 8; i++) {
            checkValid('posDiag1',  'Diag', i,      i, 7 - i,  9, i + 1);
            checkValid('posDiag2',  'Diag', i + 16, i, i * 8, -7, i + 1);
        }
        for (var i= 8; i < 13; i++) {
            checkValid('posDiag1',  'Diag', i,      i, (i - 7) * 8,  9, 15 - i);
            checkValid('posDiag2',  'Diag', i + 16, i, 49 + i,      -7, 15 - i);
        }

        result.push(""
        
            , "     validMoves= [];"
            , "     cell= 64;"
            , "     while (cell--) if (validHV[cell] || validDiag[cell]) {"
            , "         var score= cellScore[cell];"
            , "         while (score--) validMoves[validMoves.length]= cell;"
            , "     }"
        
            , "     recalcValidHV= recalcValidDiag= 0;"
            , "     return validMoves;"
            , " }"
        );

        console.log(result.join("\n"));

        eval("getValidMoves= (" + result.join('') + ");");
    }

    function unique(a) {
        var lookup= [];
        var result= [];
        for (var i= a.length; i--; ) {
            if (lookup[a[i]] == undefined) result[result.length]= a[i];
            lookup[a[i]]= 1;
        }
        return result;
    }

    // Generate specialized function for making a the specified move.
    // The produced code does pretty well nothing superfluous. Most
    // values can be prcomputed so it mainly uses constants and no loops.
    // So it's fast. If you can make it faster, please let me know!
    //
    function makeSetAt(move) {

        var movey= move >> 3;
        var movex= move & 7;

        var result= [];

        var shl= function(name, value) {
            if (value) return '(' + name + ' << ' + value + ')';
            return name;
        };

        var encloseIfContainsCode= function(aBefore, aAfter, func) {
            var lastLength= result.length;
            func();
            if (lastLength != result.length) {
                for (i in aBefore) result.splice(lastLength++, 0, aBefore[i]);
                for (i in aAfter) result.splice(result.length, 0, aAfter[i]);
            }
        };

        var recalcValid;

        var addRecalcValid= function(recalcValid, hIndex, vIndex, d1Index, d2Index) {

            return recalcValid;

            var newRecalcValid= [
                recalcValid[0] | (1 << hIndex)  | (1 << (vIndex + 16)),
                recalcValid[1] | (1 << d1Index) | (1 << (d2Index + 16))
            ];
            if (newRecalcValid[0] != recalcValid[0]) {
                result.push(""
                    , "         recalcValidHV   |= 0x" + (newRecalcValid[0] & ~recalcValid[0]).toString(16) + "; // " + newRecalcValid[0].toString(16)
                );
            }
            if (newRecalcValid[1] != recalcValid[1]) {
                result.push(""
                    , "         recalcValidDiag |= 0x" + (newRecalcValid[1] & ~recalcValid[1]).toString(16) + "; // " + newRecalcValid[1].toString(16)
                );
            }
            return newRecalcValid;
        }

        // fixme: name turn
        var flip= function(posIndex, dx, dy) {

            encloseIfContainsCode([ ""
                    , "     if (qi= pos[" + posIndex + "]) {"
                ], [ ""
                    , "}"
                ], function() {

                    var qmovex= movex;
                    var qmovey= movey;
        
                    var brackets= '';
                    var found= 0;

                    var qrecalcValid= recalcValid.concat();
        
                    for (var max= 1; max < 7; max++) {
        
                        qmovex += dx;
                        qmovey += dy;
        
                        if (qmovex < 0 || qmovex >= 8 || qmovey < 0 || qmovey >= 8) break;

                        found= max;
                                
                        var qmovex2= qmovex + qmovex;
                        var qmovey2= qmovey + qmovey;
        
                        var qmovedax= qmovex >= qmovey ? qmovey2 : qmovex2;
                        var qmoveday= qmovey - qmovex + 7;
        
                        var qmovedbx= (7 - qmovex) >= qmovey ? qmovex2 : 14 - qmovey2;
                        var qmovedby= qmovey + qmovex;
        
                        if (max > 1) {
                            result.push(""
                                , "     if (qi >= " + max + ") {"
                            );
                            brackets += '}';
                        }
                        
                        result.push(""
                            , "         posH[" + qmovey + "] ^= " + ((3 << qmovex2)) + ";"
                            , "         posV[" + qmovex + "] ^= " + ((3 << qmovey2)) + ";"
                            , "         posDiag1[" + qmoveday + "] ^= " + ((3 << qmovedax)) + ";"
                            , "         posDiag2[" + qmovedby + "] ^= " + ((3 << qmovedbx)) + ";"
                        );

                        qrecalcValid= addRecalcValid(qrecalcValid, qmovey, qmovex, qmoveday, qmovedby);
                    }

                    if (brackets.length) result.push(""
                        , '     ' + brackets
                    );
                    if (found == 1) {
                        result.push(""
                            , "         diff += colDiff + colDiff;"
                        );
                    }                    
                    else if (found > 1) {
                        result.push(""
                            , "         diff += (colDiff + colDiff) * qi;"
                        );
                    }                    
                }
            );
        };

        var movex2= movex + movex;
        var movey2= movey + movey;

        var movedax= movex >= movey ? movey2 : movex2;
        var moveday= movey - movex + 7;

        var movedbx= (7 - movex) >= movey ? movex2 : 14 - movey2;
        var movedby= movey + movex;

        result.push(""
            , " function() {"
            , "     var pos, qi;"
            , "     boardLog[boardLog.length]= " + move + ";"
            , "     diff += colDiff;"
        );

        recalcValid= addRecalcValid([0, 0], movey, movex, moveday, movedby);
        
        result.push(""
            , "     pos= posList[posH[" + movey + "] ^ colMask];"
            , "     posH[" + movey + "] |= " + shl('col', movex2) + ";"
        );

        flip(movex2 + 11, -1, 0);
        flip(movex2 + 12,  1, 0);

        result.push(""
                , "     pos= posList[posV[" + movex + "] ^ colMask];"
                , "     posV[" + movex + "] |= " + shl('col', movey2) + ";"
        );

        flip(movey2 + 11, 0, -1);
        flip(movey2 + 12, 0,  1);

        result.push(""
            , "     pos= posList[posDiag1[" + moveday + "] ^ colMask];"
            , "     posDiag1[" + moveday + "] |= " + shl('col', movedax) + ";"
        );

        flip(movedax + 11, -1, -1);
        flip(movedax + 12,  1,  1);

        result.push(""
            , "     pos= posList[posDiag2[" + movedby + "] ^ colMask];"
            , "     posDiag2[" + movedby + "] |= " + shl('col', movedbx) + ";"
        );

        flip(movedbx + 11, -1,  1);
        flip(movedbx + 12,  1, -1);

        result.push(""
            , "     col= 3 - col;"
            , "     colMask= 65535 - colMask;"
            , "     colDiff= -colDiff;"
            , " }"
        );

        // if (move == 22) { console.log(result.join("\n")); die(); }

        eval("setAt[" + move + "]= (" + result.join("\n") + ");");
    }

    function finished() {
        return boardLog.length < 4
            || boardLog.length >= 64
            || (boardLog[boardLog.length - 2] < 0 && boardLog[boardLog.length - 1]);
    }
  
    function pass() {
        if (boardLog.length >= 64) return;

        boardLog[boardLog.length]= -1;
        col= 3 - col;
        colMask= 65535 - colMask;
        colDiff= -colDiff;
    }

    // slow! but doesn't matter, not used by computer player
    function undo(count) {
        var flog2= boardLog.concat(); // clone

        initBoard();        
        for (var i= 4; i < flog2.length - count; i++) {
            if (flog2[i] < 0) {
                pass();
                continue;
            }
            setAt[flog2[i]]();
        }
    }

    // Retrieves the color of a given cell
    function colAtCell(cell) {
        var movey= cell >> 3;
        var movex= cell & 7;
        var result= (posH[movey] >> (movex + movex)) & 3;
        return result == 3 ? 0 : result;
    }
  
    var capPosH= [], capPosV= [], capPosDiag1= [], capPosDiag2= [];
    var capBoardLog= [];
/*
    var capValidHV= [], capValidDiag= [];
    var capValidMoves= [];
    var capRecalcValidHV, capRecalcValidDiag;
*/
    var capCol, capColMask, capColDiff;
    var capDiff;

    function captureBoard() {

        for (var y= 8; y--; ) {
            capPosH[y]= posH[y];
            capPosV[y]= posV[y];
        }

        for (var y= 15; y--; ) {
            capPosDiag1[y]= posDiag1[y];
            capPosDiag2[y]= posDiag2[y];
        }

        capBoardLog.splice(boardLog.length, 64);
        for (var i= boardLog.length; i--; ) {
            capBoardLog[i]= boardLog[i];
        }
/*
        capValidHV= [];
        capValidDiag= [];
        for (var i= 64; i--; ) {
            capValidHV[i]= validHV[i];
            capValidDiag[i]= validDiag[i];
        }

        capValidMoves= [];
        for (var i= validMoves.length; i--; ) {
            capValidMoves[i]= validMoves[i];
        }

        capRecalcValidHV= recalcValidHV;
        capRecalcValidDiag= recalcValidDiag;
*/
        
        capCol= col;
        capColMask= colMask;
        capColDiff= colDiff;

        capDiff= diff;
    }

    function restoreBoard() {

        for (var y= 8; y--; ) {
            posH[y]= capPosH[y];
            posV[y]= capPosV[y];
        }

        for (var y= 15; y--; ) {
            posDiag1[y]= capPosDiag1[y];
            posDiag2[y]= capPosDiag2[y];
        }

        boardLog.splice(capBoardLog.length, 64);
        for (var i= capBoardLog.length; i--; ) {
            boardLog[i]= capBoardLog[i];
        }
/*
        validHV= [];
        validDiag= [];
        for (var i= 64; i--; ) {
            validHV[i]= capValidHV[i];
            validDiag[i]= capValidDiag[i];
        }

        validMoves= [];
        for (var i= capValidMoves.length; i--; ) {
            validMoves[i]= capValidMoves[i];
        }

        recalcValidHV= capRecalcValidHV;
        recalcValidDiag= capRecalcValidDiag;
*/
        
        col= capCol;
        colMask= capColMask;
        colDiff= capColDiff;

        diff= capDiff;
    }


    function restoreBoard_old() {

        var tmp;

        tmp= posH; posH= capPosH; capPosH= tmp;
        tmp= posV; posV= capPosV; capPosV= tmp;

        tmp= posDiag1; posDiag1= capPosDiag1; capPosDiag1= tmp;
        tmp= posDiag2; posDiag2= capPosDiag2; capPosDiag2= tmp;

        tmp= boardLog; boardLog= capBoardLog; capBoardLog= tmp;
/*
        validHV= capValidHV;
        validDiag= capValidDiag;

        validMoves= capValidMoves;

        recalcValidHV= capRecalcValidHV;
        recalcValidDiag= capRecalcValidDiag;
*/
        col= capCol;
        colMask= capColMask;
        colDiff= capColDiff;

        diff= capDiff;
    }

    function computeMove(tip) {
        var moves= unique(getValidMoves());
        if (moves.length == 0) {
            status('Pass. I can\'t make a move :-(', 3);
            pass();
            refreshBoard();
            return;
        }

        var secs= document.getElementById('time').value;
        if (secs < 1) secs= 1;

        var games= 0;

        var doMove= function(move) {
            if (!tip) {
                setAt[move]();
                refreshBoard();
                markCell(move, 'last-move');
            }
            else {
                markCell(move, 'tip-move');
            }
    
            status('Done.'
                    + ' My move is (' + move + ') ' + (move & 7) + ',' + (move >> 3) + '.'
                    + ' Calculated ' + games + ' games.'
                , 3);
        }

        if (moves.length == 1) {
            doMove(moves[0]);
            return;
        }

        endTime= new Date().getTime() + secs * 1000;
        
        // Consume last 1/3 of the time only playing the best three moves so far
        var resortTime= new Date().getTime() + secs * 666;

        var moveScore= [];
        for (var movei in moves) {
            moveScore[moves[movei]]= 0;
        }

        var dots= '';

        captureBoard();

        var inner= function() {

            if (new Date().getTime() < endTime) {

                status("Thinking" + dots, 0, 1);
                dots= dots.length > 30 ? '' : dots + '.';

                // If a certain amount of time is used up, concentrate on the
                // so far best three moves.
                if (resortTime && new Date().getTime() > resortTime) {
                    console.log("Resorting...");
                    if (moves.length > 3) {
                        moves.sort(function(a, b) { return moveScore[b] - moveScore[a]; });
                        moves.splice(3, 64);
                        
                        // Reset the scores.
                        // TODO: Is that a good idea?
                        for (var movei in moves) {
                            moveScore[moves[movei]]= 0;
                        }
                    }
                    resortTime= 0;
                }

                var nextMoves;
                var nextMove;
                var movei;

                for (var n= 10; n--; ) {
                    for (movei in moves) {
                        restoreBoard();
                        setAt[moves[movei]]();

                        while (1) {
                            nextMoves= getValidMoves();
                            if (nextMoves.length == 0) {
                                pass();
                                nextMoves= getValidMoves();
                                if (nextMoves.length == 0) break;
                            }
                            nextMove= nextMoves[Math.floor(Math.random() * nextMoves.length)];
                            setAt[nextMove]();
                        }        

                        if (capCol == 1) {
                            if (diff > 0) moveScore[moves[movei]]++;
                            if (diff < 0) moveScore[moves[movei]]--;
                        }
                        else {
                            if (diff < 0) moveScore[moves[movei]]++;
                            if (diff > 0) moveScore[moves[movei]]--;
                        }

                        games++;
                    }
                }
                setTimeout(inner, 10);
                return;
            }

            restoreBoard();
            endTime= 0;
    
            moves.sort(function(a, b) { return moveScore[b] - moveScore[a]; });

            console.log(getValidMoves());

            var scores= '';
            for (var movei in moves) {
                scores += ' ' + moves[movei] + ':' + moveScore[moves[movei]];
            }
            console.log("Scores:" + scores);
    
            doMove(moves[0]);
            
            // console.log(moveScore);
        }

        setTimeout(inner, 10);
    }

    // ====================================================================
    //  Output
    // ====================================================================

    // See: http://de.wikipedia.org/wiki/Benutzer:Buncic/Unicode/Geometrische_Formen
    function stone(col) {
        return ' \u25CB\u25CF '.substr(col & 3, 1);
    }

    function stoneBg(col) {
        return ' \u25CF  '.substr(col & 3, 1);
    }

    function colName(col) {
        if (col == 1) return "White";
        if (col == 2) return "Black";
        return "?"
    }

    function defaultStatus() {
        clearTimeout(hStatusTimer);
        hStatusTimer= null;
        var status= finished() ? 'wins' : 'leads';
        if (diff > 0) {
            status= 'White ' + status + ' by ' + diff + ' points';
        }
        else if (diff < 0) {
            status= 'Black ' + status + ' by ' + (-diff) + ' points';
        }
        else {
            status= finished() ? 'it\'s a draw' : 'The game is even';
        }
        if (finished()) {
            status= 'Game over, ' + status + '!';
        }
        else {
            status= colName(col) + '\'s turn. ' + status + '.';
        }
        document.getElementById('status').innerHTML= status;
    }

    function status(html, secs, noConsole) {
        if (!noConsole) console.log('STATUS: ' + html);
        document.getElementById('status').innerHTML= html;
        if (hStatusTimer) {
            clearTimeout(hStatusTimer);
            hStatusTimer= null;
        }
        if (secs) {
            hStatusTimer= setTimeout(defaultStatus, secs * 1000);
        }
    }

    function printBoard() {

        var html= '<table>';
        var i= 0;
        for (var y= 0; y < 8; y++) {
            html += '<tr>';
            for (var x= 0; x < 8; x++, i++) {
                html += '<td onclick="clickCell(' + i + ')" id="cell' + i + '"></td>';
            }
            html += '</tr>';
        }
        html += '</table>';
        document.getElementById('board').innerHTML= html;

        refreshBoard();
    }

    function refreshBoard() {
        var i= 0;
        for (var y= 0; y < 8; y++) {
            var pos= posH[y];
            for (var x= 0; x < 8; x++) {
                (document.getElementById('cell' + i) || {}).innerHTML=
                      '<div class="cell">'
                    +   '<div class="num debug">' + i + '</div>'
                    +   '<div class="stone-bg">' + stoneBg(pos) + '</div>'
                    +   '<div class="stone-fg">' + stone(pos) + '</div>'
                    + '</div>'
                pos >>= 2;
                i++;
            }
        }
        var cells= finished() ? [] : getValidMoves();

        unmarkAllCells();
        for (var i in cells) markCell(cells[i], 'valid-move-' + col);
    }

    function unmarkAllCells() {
        for (var i= 0; i < 64; i++) {
            (document.getElementById('cell' + i) || {}).className= '';
        }
    }

    function markCell(cell, class_) {
         (document.getElementById('cell' + cell) || {}).className= class_;
    }

    // ====================================================================
    //  Debugging
    // ====================================================================

    function pldump(pos) {

        var newpos= pos;
        var i= 8;
        var result= '';
        while (i--) {
            result += '.OX,'.substr((newpos ^ colMask) & 3, 1);
            newpos >>= 2;
        }
        return result + ' ' + pos;
    }

    function clickDump(posXName) {
        if (posXName == 'validMoves') {
            console.log(getValidMoves());
            return
        }
        var posX;
        if (posXName == 'posH') posX= posH;
        if (posXName == 'posV') posX= posV;
        if (posXName == 'posDiag1') posX= posDiag1;
        if (posXName == 'posDiag2') posX= posDiag2;
        console.log('============= ' + posXName + ' =============');
        for (var i= 0; i < posX.length; i++) {
            console.log(pldump(posX[i] ^ colMask));
        }
    }

    // ====================================================================
    //  UI
    // ====================================================================

    function isComputersTurn() {
        if (endTime) {
            status("Please wait until the computer made it's move!");
            return 1;
        }
        return 0;
    }

    function clickCell(move) {
        if (isComputersTurn()) return;
        if (finished()) return;
        
        if (colAtCell(move)) {
            status("Cell is already taken!", 3);
            return;
        }

        var moves= unique(getValidMoves());
        var ok= 0;
        for (var movei in moves) {
            if (moves[movei] == move) { ok= 1; break; }
        }
        if (!ok) {
            status("Not a valid move!", 2);
            return;
        }

        setAt[move]();
        refreshBoard();
        markCell(move, 'last-move');

        if (computerCol == col) {
            computeMove();
        }
    }

    function clickNewGame() {
        if (isComputersTurn()) return;

        initBoard();
        refreshBoard();
    }

    function clickUndo() {
        if (isComputersTurn()) return;
        if (boardLog.length <= 4) {
            console.log("CAN'T UNDO");
            return;
        }

        undo(computerCol ? 2 : 1);
        refreshBoard();
        if (boardLog.length > 4 && boardLog[boardLog.length - 1] > 0) {
            markCell(boardLog[boardLog.length - 1], 'last-move');
        }
        defaultStatus();
    }

    function clickPass() {
        if (isComputersTurn()) return;
        if (finished()) return;

        pass();
        refreshBoard();
        defaultStatus();

        if (computerCol == col) {
            computeMove();
        }
    }

    function clickTip() {
        if (isComputersTurn()) return;
        if (finished()) return;

        refreshBoard();
        computeMove(1);
    }

    function doOnload() {

        status("Initializing, please hold on a second...");

        initCellScore();

        makeGetValidMoves();

        setAt= []
        for (var i= 0; i < 64; i++) {
            makeSetAt(i);
        }
        
        initPosList();

        var ready= function() {
            if (!initPosListDone) {
                setTimeout(ready, 100);
                return;
            }
            initBoard();
            printBoard();
        }
        setTimeout(ready, 100);
    }

</script>
<style>
    body {
        font-family: Tahoma, sans-serif;
        height: 100.1%;
        border: 0;
        margin: 0;
    }
    #board table {
        border-collapse: collapse;
        border: solid 6px #988579;
        background-color: #DABFAD;
    }
    #board table tr {
        vertical-align: top;
    }
    #board table td {
        border: solid 3px #B8A192;
        width: 40px;
        height: 40px;
        text-align: center;
        cursor: pointer;
    }
    #board .cell {
        position: relative;
        overflow: hidden;
        width: 40px;
        height: 40px;
    }
    #board .cell div {
        width: 40px;
        text-align: center;
        position: absolute;
        margin: 0;
        padding: 0;
    }
    #board .cell .num {
        font-size: 8px;
        color: #FFF;
    }
    #board .cell .stone-bg, #board .cell .stone-fg {
        top: -15px;
        font-size: 300%;
    }
    #board .cell .stone-bg {
        color: #fff;
    }
    #board .valid-move-1 {
        background-color: #F2D4C0;  /* whitish */
    }
    #board .valid-move-2 {
        background-color: #A79285;  /* blackish */
    }
    /* red: E55252 yellow: E5E052 */
    #board .last-move {
        background-color: #52C1E5;  /* blue */
    }
    #board .tip-move {
        background-color: #52E574;  /* green */
    }
    #console {
        padding: 20px;
        margin: 20px;
        border: 1px solid #888;
    }
    .button {
        -moz-border-radius: 6px;
        -webkit-border-radius: 6px;
        padding: 4px 10px;
        border: solid 2px black;
        background-color: #EEE;
        text-decoration: none;
        color: #000;
    }
    .button:hover {
        background-color: #DDD;
    }
    .debug {
        x-display: none;
    }
    #head {
        background-color: black;        
        padding: 10px 20px ;
        margin: 0 0 20px 0;
        color: #FFF;
        text-align: right;
    }
    #head h1 {
        float: left;
        text-weight: bold;
        font-size: 100%;
        padding: 0;
        margin: 0;
        color: #F2D4C0;
    }
    #head a {
        color: #FFF;
    }
    #body {
        padding: 10px;
    }
</style>
</head>
<body onload="doOnload()">
    <div id="head">
        <h1>MoThello</h1>
        (c) 2008 by Dietrich Raisin, info@raisin.de, <a href="http://www.raisin.de/">www.raisin.de</a>
    </div>
    <div id="body">
        <div>
            <a class="button" href="javascript:clickNewGame();">New Game</a>
            <a class="button" href="javascript:clickUndo();">Undo</a>
            <a class="button" href="javascript:clickPass();">Pass</a>
            <a class="button" href="javascript:clickTip();">Tip</a>
            Time: <input id="time" size="2" value="8">s
        
            <span class="debug">
                <a class="button" href="javascript:clickDump('posH');">posH</a>
                <a class="button" href="javascript:clickDump('posV');">posV</a>
                <a class="button" href="javascript:clickDump('posDiag1');">posDiag1</a>
                <a class="button" href="javascript:clickDump('posDiag2');">posDiag2</a>
                <a class="button" href="javascript:clickDump('validMoves');">validMoves</a>
            </span>
        </div>
        <br />
        <div id="status">&nbsp;</div>
        <br />
        <div id="board"></div>
        <div id="console" class="debug"></div>
    </div>
</body>
