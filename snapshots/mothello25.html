<script>

    // ====================================================================
    //  MoReversi Version 2008-08-20. Inspired by MoGo.
    //  (c) 2008 by Dietrich Raisin, info1@raisin.de, www.raisin.de
    //
    //  Released under the Artistic License 2.0. Here are the terms:
    //  http://www.opensource.org/licenses/artistic-license-2.0.php
    // ====================================================================

    if (typeof console == 'undefined') {

        // Firebug Feather :-)
        console= {
            log: function(value) {
                var lines= document.getElementById('console').innerHTML.split('<br>');
                lines.push(value);
                while (lines.length > 15) lines.shift();
                document.getElementById('console').innerHTML= lines.join('<br>');
            }
        };
    }

    var boardLog;               // Log of the moves made

    var posH;                   // Board from a horizontal point of view
    var posV;                   // Board from a vertical point of view
    var posDiag1;               // Board from a diagonal point of view
    var posDiag2;               // Board from the other diagonal point of view

    var col;                    // Current player's color. 1 (white) or 2 (black).
    var colMask;                // 0 if col == 1, or 0xFFFF if col == 2
    var colDiff;                // 1 if col == 1, or -1 if col == 2
    
    var diff;                   // Current score (if positive, points that white is ahead, otherwise -points that black is ahead)

    var posList;                // See initPosList
    var initPosListDone;
    
    var undefined= undefined;   // jQuery does that. So it's correct. qed.

    var getValidMoves;          // Function generated by makeGetValidMoves()
    var validMovesCheck;        // Flag indicating if the board is already initialized

    var hStatusTimer= null;     // Used by status(). Timer for switching back the status information to default value

    var endTime= 0;             // Used by computeMove()

    var cellScore;

    var setAt2;

    // ====================================================================
    //  Core
    // ====================================================================

    function initCellScore() {
        cellScore= [];
        for (var i= 0; i < 64; i++) {
            cellScore[i]= 2;
        }
        for (var i= 0; i < 8; i++) {
            cellScore[i] += 2;
            cellScore[i * 8] += 2;
            cellScore[i + 56] += 2;
            cellScore[i * 8 + 7] += 2;
        }
        for (var i= 2; i < 6; i++) {
            cellScore[i + 16]++;
            cellScore[i * 8 + 2]++;
            cellScore[i + 40]++;
            cellScore[i * 8 + 5]++;
        }
        cellScore[9]= cellScore[14]= cellScore[49]= cellScore[54]= 1;
    }

    function initMovesCheck() {
        validMovesCheck= [];

        for (var i= 64; i--; ) {
            validMovesCheck.push(0);
        }
    }

    function initBoard() {
        posH= [];
        posV= [];
        posDiag1= [];
        posDiag2= [];
        
        for (var y= 8; y--; ) {
            posH.push(0);
            posV.push(0);
        }

        for (var y= 15; y--; ) {
            posDiag1.push(0);
            posDiag2.push(0);
        }

        boardLog= [];

        col= 1;
        colMask= 0;
        colDiff= 1;
        
        diff= 0;

        setAt2[27]();
        setAt2[28]();
        setAt2[36]();
        setAt2[35]();

        // setAt2[29](); setAt2[37](); setAt2[45](); setAt2[38](); setAt2[42](); setAt2[22]();

        status("Let's go!", 1);
    }

    //  The entries for all possible positions for one row are stored in the
    //  posList array. The index consists of 2 * 8 bits for the 8 cells. 2 bits
    //  are used as follows: 0= empty, 1=white, 2=black, 3=empty.
    //
    //  The entries can be used for either opponent. One of the opponent
    //  looks up posList[n], the other posList[n ^ 0xffff].
    //
    //  Each entry looks like this:
    //  [ valid2, valid1, valid0,
    //      newpos0, newpos1, ... , newpos7,
    //      flipped0-left, flipped0-right, flipped1-left, flipped1-right, ... , flipped7-left, flipped7-right,
    //  ]
    //
    //  validN      0..  Valid moves for white in that position.
    //
    //  newposN     3..  New position if white's move is N.
    //              The new position includes the flipped captures stones if there are any.
    //
    //  flippedN    11.. Number of flipped stones to the left and to the right if white's move is N.
    //
    //  // set1N       27.. DOCME
    //
    //  // set2N       35.. DOCME
    //
    function initPosList() {
    
        initPosListDone= 0;
        posList= new Array(65536);

        var pos0= 0;

        var nextChunk= function() {

            var pos,
                had, had1pos,
                want1, want2, wantpos,
                j,
                valid,
                newpos, flipped; // , set1, set2;

            for (chunk= 8192; chunk--; pos0++) {
    
                pos= pos0;
                had= want1= want2= 0;
                had1pos= wantpos= -1;
                valid= [ 9, 9, 9 ];
                newpos= [ pos0, pos0, pos0, pos0, pos0, pos0, pos0, pos0 ];
                flipped= [ 0, 0,  0, 0,  0, 0,  0, 0,  0, 0,  0, 0,  0, 0,  0, 0 ];
                validi= 0;
    
                for (j= 0; j < 8; j++) {

                    if ((pos & 3) == 1) {
                        if (wantpos >= 0) {
                            if (want2) {
                                valid[validi++]= wantpos;
                                
                                // Flip captured stones
                                newpos[wantpos] ^=
                                    ~(-1 << (j + j - wantpos - wantpos - 2))
                                    << (wantpos + wantpos + 2);
                                flipped[wantpos + wantpos + 1]= j - wantpos -1;
                            }
                            wantpos= -1;
                        }
                        had= 1;
                        want2= 0;
                        newpos[j]= undefined;
                    }
                    else if ((pos & 3) == 2) {
                        if (had == 1) {
                            had= 2;
                            had1pos= j;
                        }
                        want2= 1;
                        newpos[j]= undefined;
                    }
                    else {
                        if (had == 2) {
                            valid[validi++]= j;

                            // Flip captured stones
                            newpos[j] ^=
                                ~(-1 << (j + j - had1pos - had1pos))
                                << (had1pos + had1pos);
                            flipped[j + j]= j - had1pos;
                        }
                        wantpos= j;
                        had= want1= want2= 0;

                        newpos[j]= newpos[j] & ~(3 << (j + j)) | (1 << (j + j));
                    }

                    pos >>= 2;
                }

                // Additionally to it's purpose of concating, "concat" clones the array, which is
                // what we need here.
                posList[pos0]= valid.sort().concat(newpos).concat(flipped); // .concat(set1).concat(set2);

                // console.log(valid);
            }
            if (pos0 < 65536) {
                setTimeout(nextChunk, 1);
                return;
            }
            initPosListDone= 1;
            console.log("initPosList DONE");
        }
        setTimeout(nextChunk, 1);
    }

    // Builds an optimized function that calculated the valid moves.
    // The resulting function contains no loops, but too many ifs :-/
    //
    function makeGetValidMoves() {

        var result= [];

        result.push(""
            , " function() {"
            , "     var check= validMovesCheck.concat();"
            , "     var valid, cell;"
            , "     var result= [];"
        );

        var checkValid= function(posArray, move, base, mul, len) {

            // result[result.length] is faster than result.push, according to the net

            result.push(""
                , "     valid= posList[" + posArray + "[" + move + "] ^ colMask];"
            );

            if (mul == -1) mul= ' - ';
            else if (mul == 1) mul= (base ? ' + ' : '');
            else if (mul > 0) mul= (base ? ' + ' : '') + mul + ' * ';
            else mul= (base ? ' - ' : ' -') + -mul + ' * ';

            if (base == 0) base= '';

            for (var i= 0; i < 3; i++) {
                result.push(""
                    , "     if (valid[" + i + "] < " + len + ") {"
                    , "         cell= " + base + mul + "valid[" + i + "];"
                    , "         if (check[cell] == 0) {"
                    , "             check[cell]= 1;"
                    , "             var score= cellScore[cell];"
                    , "             while (score--) result[result.length]= cell;"
                    , "         }"
                );
            };
            result.push(""
                , "     }}}"
            );
        }

        for (var i= 0; i < 8; i++) {
            checkValid('posH',      i, i * 8, 1, 8);
            checkValid('posV',      i, i,     8, 8);
        }
        for (var i= 2; i < 8; i++) {
            checkValid('posDiag1',  i, 7 - i, 9,  i + 1);
            checkValid('posDiag2',  i, i * 8, -7, i + 1);
        }
        for (var i= 8; i < 13; i++) {
            checkValid('posDiag1',  i, (i - 7) * 8, 9,  15 - i);
            checkValid('posDiag2',  i, 49 + i,      -7, 15 - i);
        }

        result.push(""
            , "     return result;"
            , " }"
        );

        // console.log(result.join("\n"));

        eval("getValidMoves= (" + result.join('') + ");");
    }

    function unique(a) {
        var lookup= [];
        var result= [];
        for (var i= a.length; i--; ) {
            if (lookup[a[i]] == undefined) result[result.length]= a[i];
            lookup[a[i]]= 1;
        }
        return result;
    }

    function setAt(move) {

        setAt2[move]();
        return;


        var movey= move >> 3;
        var movex= move & 7;
        var pos, qi;

        var movex2, movey2;
        var movexd, moveyd;

        var qmovex, qmovey;
        var qmovex2, qmovey2;
        var qmovexd, qmoveyd;

        var plColInx= 19 + col * 8;

        var quickSetAt= function(dx, dy) {

            qmovex= movex;
            qmovey= movey;

            while (qi) {

                diff += colDiff + colDiff;

                // console.log("QUICKSET x=" + qmovex + " y=" + qmovey + " diff=" + diff);

                qmovex += dx;
                qmovey += dy;
                qmovex2= qmovex + qmovex;
                qmovey2= qmovey + qmovey;

                posH[qmovey]= posH[qmovey] & ~(3 << qmovex2) | (col << qmovex2);
    
                posV[qmovex]= posV[qmovex] & ~(3 << qmovey2) | (col << qmovey2);
    
                qmovexd= qmovex >= qmovey ? qmovey2 : qmovex2;
                qmoveyd= qmovey - qmovex + 7;
                posDiag1[qmoveyd]= posDiag1[qmoveyd] & ~(3 << qmovexd) | (col << qmovexd);
    
                qmovexd= (7 - qmovex) >= qmovey ? qmovex2 : 14 - qmovey2;
                qmoveyd= qmovey + qmovex;
                posDiag2[qmoveyd]= posDiag2[qmoveyd] & ~(3 << qmovexd) | (col << qmovexd);

                qi--;
            }
        };

        boardLog[boardLog.length]= move;
        diff += colDiff;

        movex2= movex + movex;
        movey2= movey + movey;

        pos= posList[posH[movey] ^ colMask];
        posH[movey] |= col << movex2;

        if (qi= pos[movex2 + 11]) quickSetAt(-1, 0);
        if (qi= pos[movex2 + 12]) quickSetAt( 1, 0);

        pos= posList[posV[movex] ^ colMask];
        posV[movex] |= col << movey2;

        if (qi= pos[movey2 + 11]) quickSetAt(0, -1);
        if (qi= pos[movey2 + 12]) quickSetAt(0,  1);

        movexd= movex >= movey ? movey2 : movex2;
        moveyd= movey - movex + 7;
        pos= posList[posDiag1[moveyd] ^ colMask];
        posDiag1[moveyd] |= col << movexd;

        if (qi= pos[movexd + 11]) quickSetAt(-1, -1);
        if (qi= pos[movexd + 12]) quickSetAt( 1,  1);

        movexd= (7 - movex) >= movey ? movex2 : 14 - movey2;
        moveyd= movey + movex;
        pos= posList[posDiag2[moveyd] ^ colMask];
        posDiag2[moveyd] |= col << movexd;

        if (qi= pos[movexd + 11]) quickSetAt(-1,  1);
        if (qi= pos[movexd + 12]) quickSetAt( 1, -1);

        col= 3 - col;
        colMask= 65535 - colMask;
        colDiff= -colDiff;

        // console.log("SETAT: diff=" + diff);
    }

    function makeSetAt(move) {

        var movey= move >> 3;
        var movex= move & 7;

        var movex2, movey2;
        var movexd, moveyd;

        var result= [];

        var shl= function(name, value) {
            if (value) return '(' + name + ' << ' + value + ')';
            return name;
        };

        var encloseIfContainsCode= function(aBefore, aAfter, func) {
            var lastLength= result.length;
            func();
            if (lastLength != result.length) {
                for (i in aBefore) result.splice(lastLength++, 0, aBefore[i]);
                for (i in aAfter) result.splice(result.length, 0, aAfter[i]);
            }
        };

        // fixme: name turn
        var flip= function(posIndex, dx, dy) {

            encloseIfContainsCode([ ""
                    , "     if (qi= pos[" + posIndex + "]) {"
                ], [ ""
                    , "}"
                ], function() {

                    var qmovex= movex;
                    var qmovey= movey;
        
                    var brackets= '';
        
                    for (var max= 1; max < 7; max++) {
        
                        qmovex += dx;
                        qmovey += dy;
        
                        if (qmovex < 0 || qmovex >= 8 || qmovey < 0 || qmovey >= 8) break;
        
                        var qmovex2= qmovex + qmovex;
                        var qmovey2= qmovey + qmovey;
        
                        var qmovedax= qmovex >= qmovey ? qmovey2 : qmovex2;
                        var qmoveday= qmovey - qmovex + 7;
        
                        var qmovedbx= (7 - qmovex) >= qmovey ? qmovex2 : 14 - qmovey2;
                        var qmovedby= qmovey + qmovex;
        
                        if (max > 1) {
                            result.push(""
                                , "     if (qi >= " + max + ") {"
                            );
                            brackets += '}';
                        }
                        
                        result.push(""
                            , "         diff += colDiff + colDiff;"
        
                            // console.log("QUICKSET x=" + qmovex + " y=" + qmovey + " diff=" + diff);
        
                            , "         posH[" + qmovey + "]= posH[" + qmovey + "] & " + (~(3 << qmovex2)) + " | " + shl('col', qmovex2) + ";"
                            , "         posV[" + qmovex + "]= posV[" + qmovex + "] & " + (~(3 << qmovey2)) + " | " + shl('col', qmovey2) + ";"
                            , "         posDiag1[" + qmoveday + "]= posDiag1[" + qmoveday + "] & " + (~(3 << qmovedax)) + " | " + shl('col', qmovedax) + ";"
                            , "         posDiag2[" + qmovedby + "]= posDiag2[" + qmovedby + "] & " + (~(3 << qmovedbx)) + " | " + shl('col', qmovedbx) + ";"
                        );
                    }
                    
                    if (brackets.length) result.push(""
                        , '   ' + brackets
                    );
                }
            );
        };

        movex2= movex + movex;
        movey2= movey + movey;

        result.push(""
            , " function() {"
            , "     var pos, qi;"
            , "     boardLog[boardLog.length]= " + move + ";"
            , "     diff += colDiff;"
            , "     pos= posList[posH[" + movey + "] ^ colMask];"
            , "     posH[" + movey + "] |= " + shl('col', movex2) + ";"
        );
        
        flip(movex2 + 11, -1, 0);
        flip(movex2 + 12,  1, 0);

        result.push(""
                , "     pos= posList[posV[" + movex + "] ^ colMask];"
                , "     posV[" + movex + "] |= " + shl('col', movey2) + ";"
        );

        flip(movey2 + 11, 0, -1);
        flip(movey2 + 12, 0,  1);

        movexd= movex >= movey ? movey2 : movex2;
        moveyd= movey - movex + 7;

        result.push(""
            , "     pos= posList[posDiag1[" + moveyd + "] ^ colMask];"
            , "     posDiag1[" + moveyd + "] |= " + shl('col', movexd) + ";"
        );

        flip(movexd + 11, -1, -1);
        flip(movexd + 12,  1,  1);

        movexd= (7 - movex) >= movey ? movex2 : 14 - movey2;
        moveyd= movey + movex;

        result.push(""
            , "     pos= posList[posDiag2[" + moveyd + "] ^ colMask];"
            , "     posDiag2[" + moveyd + "] |= " + shl('col', movexd) + ";"
        );

        flip(movexd + 11, -1,  1);
        flip(movexd + 12,  1, -1);

        result.push(""
            , "     col= 3 - col;"
            , "     colMask= 65535 - colMask;"
            , "     colDiff= -colDiff;"
            , " }"
        );

        // if (move == 22) { console.log(result.join("\n")); die(); }

        eval("setAt2[" + move + "]= (" + result.join("\n") + ");");
    }

    function pass() {
        if (boardLog.length >= 64) return;

        boardLog[boardLog.length]= -1;
        col= 3 - col;
        colMask= 65535 - colMask;
        colDiff= -colDiff;
    }

    // slow! but doesn't matter, not used by computer player
    function undo(count) {
        var flog2= boardLog.concat(); // clone

        initBoard();        
        for (var i= 4; i < flog2.length - count; i++) {
            if (flog2[i] < 0) {
                pass();
                continue;
            }
            setAt2[flog2[i]]();
        }
    }

    function colAtMove(move) {
        var movey= move >> 3;
        var movex= move & 7;
        var result= (posH[movey] >> (movex + movex)) & 3;
        return result == 3 ? 0 : result;
    }
  
    function autoPlay() {
        while (1) {
            var moves= getValidMoves();
            if (moves.length == 0) {
                pass();
                moves= getValidMoves();
                if (moves.length == 0) break;
            }
            var move= moves[Math.floor(Math.random() * moves.length)];
            setAt2[move]();
        }        
    }

    var capPosH= [], capPosV= [], capPosDiag1= [], capPosDiag2= [], capBoardLog= [];
    var capCol, capColMask, capColDiff, capDiff;

    function captureBoard() {

        for (var y= 8; y--; ) {
            capPosH[y]= posH[y];
            capPosV[y]= posV[y];
        }

        for (var y= 15; y--; ) {
            capPosDiag1[y]= posDiag1[y];
            capPosDiag2[y]= posDiag2[y];
        }

        capBoardLog.splice(boardLog.length, 64);
        
        for (var i= boardLog.length; i--; ) {
            capBoardLog[i]= boardLog[i];
        }
        
        capCol= col;
        capColMask= colMask;
        capColDiff= colDiff;
        capDiff= diff;
    }

    function restoreBoard() {

        col= capCol;
        colMask= capColMask;
        colDiff= capColDiff;
        diff= capDiff;

        var tmp;
        
        tmp= boardLog;
        boardLog= capBoardLog;
        capBoardLog= tmp;

        tmp= posH;
        posH= capPosH;
        capPosH= tmp;

        tmp= posV;
        posV= capPosV;
        capPosV= tmp;

        tmp= posDiag1;
        posDiag1= capPosDiag1;
        capPosDiag1= tmp;

        tmp= posDiag2;
        posDiag2= capPosDiag2;
        capPosDiag2= tmp;
    }

    function computeMove(tip) {
        var moves= unique(getValidMoves());
        if (moves.length == 0) {
            status('Pass. I can\'t make a move :-(', 3);
            pass();
            refreshBoard();
            return;
        }

        var secs= document.getElementById('time').value;
        if (secs < 1) secs= 1;

        var games= 0;

        var doMove= function(move) {
            if (!tip) {
                setAt2[move]();
                refreshBoard();
                markCell(move, 'last-move');
            }
            else {
                markCell(move, 'tip-move');
            }
    
            status('Done.'
                    + ' My move is (' + move + ') ' + (move & 7) + ',' + (move >> 3) + '.'
                    + ' Calculated ' + games + ' games.'
                , 3);
        }

        if (moves.length == 1) {
            doMove(moves[0]);
            return;
        }

        endTime= new Date().getTime() + secs * 1000;
        
        // Consume last 1/3 of the time only playing the best three moves so far
        var resortTime= new Date().getTime() + secs * 666;

        var moveScore= {};
        for (var movei in moves) {
            moveScore[moves[movei]]= 0;
        }

        var dots= '';

        var inner= function() {

            if (new Date().getTime() < endTime) {

                status("Thinking" + dots);
                dots= dots.length > 30 ? '' : dots + '.';

                // If a certain amount of time is used up, concentrate on the
                // so far best three moves.
                if (resortTime && new Date().getTime() > resortTime) {
                    console.log("Resorting...");
                    if (moves.length > 3) {
                        moves.sort(function(a, b) { return moveScore[b] - moveScore[a]; });
                        moves.splice(3, 64);
                        
                        // Reset the scores.
                        // TODO: Is that a good idea?
                        for (var movei in moves) {
                            moveScore[moves[movei]]= 0;
                        }
                    }
                    resortTime= 0;
                }

                for (var n= 10; n--; ) {
                    for (var movei in moves) {
                        captureBoard();
                        setAt2[moves[movei]]();
                        autoPlay();

                        if (capCol == 1) {
                            if (diff > 0) moveScore[moves[movei]] += 2;
                            if (diff < 0) moveScore[moves[movei]] -= 3;
                        }
                        else {
                            if (diff < 0) moveScore[moves[movei]] += 2;
                            if (diff > 0) moveScore[moves[movei]] -= 3;
                        }

                        restoreBoard();
                        games++;
                    }
                }
                setTimeout(inner, 10);
                return;
            }

            endTime= 0;
    
            moves.sort(function(a, b) { return moveScore[b] - moveScore[a]; });

            console.log(getValidMoves());

            var scores= '';
            for (var movei in moves) {
                scores += ' ' + moves[movei] + ':' + moveScore[moves[movei]];
            }
            console.log("Scores:" + scores);
    
            doMove(moves[0]);
            
            // console.log(moveScore);
        }

        setTimeout(inner, 10);
    }

    // ====================================================================
    //  Output
    // ====================================================================

    // See: http://de.wikipedia.org/wiki/Benutzer:Buncic/Unicode/Geometrische_Formen
    function stone(col) {
        return ' \u25CB\u25CF '.substr(col & 3, 1);
    }

    function stoneBg(col) {
        return ' \u25CF  '.substr(col & 3, 1);
    }

    function colName(col) {
        if (col == 1) return "White";
        if (col == 2) return "Black";
        return "?"
    }

    function status(html, secs) {
        console.log('STATUS: ' + html);
        document.getElementById('status').innerHTML= html;
        if (hStatusTimer) {
            clearTimeout(hStatusTimer);
            hStatusTimer= null;
        }
        if (secs) {
            hStatusTimer= setTimeout(function() {
                var over= boardLog.length >= 64;
                var status= over ? 'wins' : 'leads';
                if (diff > 0) status= 'White ' + status + ' by ' + diff + ' points';
                else if (diff < 0) status= 'Black ' + status + ' by ' + (-diff) + ' points';
                else status= over ? 'it\'s a draw' : 'The game is even';
                if (over) {
                    status= 'Game over, ' + status + '!';
                }
                else {
                    status= 'Next move: ' + colName(col) + '. ' + status + '.';
                }
                document.getElementById('status').innerHTML= status;
            }, secs * 1000);
        }
    }

    function printBoard() {

        var html= '<table>';
        var i= 0;
        for (var y= 0; y < 8; y++) {
            html += '<tr>';
            for (var x= 0; x < 8; x++, i++) {
                html += '<td onclick="clickCell(' + i + ')" id="cell' + i + '"></td>';
            }
            html += '</tr>';
        }
        html += '</table>';
        document.getElementById('board').innerHTML= html;

        refreshBoard();
    }

    function refreshBoard() {
        var i= 0;
        for (var y= 0; y < 8; y++) {
            var pos= posH[y];
            for (var x= 0; x < 8; x++) {
                (document.getElementById('cell' + i) || {}).innerHTML=
                      '<div class="cell">'
                    +   '<div class="num debug">' + i + '</div>'
                    +   '<div class="stone-bg">' + stoneBg(pos) + '</div>'
                    +   '<div class="stone-fg">' + stone(pos) + '</div>'
                    + '</div>'
                pos >>= 2;
                i++;
            }
        }
        var cells= getValidMoves();

        unmarkAllCells();
        for (var i in cells) markCell(cells[i], 'valid-move-' + col);
    }

    function unmarkAllCells() {
        for (var i= 0; i < 64; i++) {
            (document.getElementById('cell' + i) || {}).className= '';
        }
    }

    function markCell(cell, class_) {
         (document.getElementById('cell' + cell) || {}).className= class_;
    }

    // ====================================================================
    //  Debugging
    // ====================================================================

    function pldump(pos) {

        var newpos= pos;
        var i= 8;
        var result= '';
        while (i--) {
            result += '.OX,'.substr((newpos ^ colMask) & 3, 1);
            newpos >>= 2;
        }
        return result + ' ' + pos;
    }

    function clickDump(posXName) {
        if (posXName == 'validMoves') {
            console.log(getValidMoves());
            return
        }
        var posX;
        if (posXName == 'posH') posX= posH;
        if (posXName == 'posV') posX= posV;
        if (posXName == 'posDiag1') posX= posDiag1;
        if (posXName == 'posDiag2') posX= posDiag2;
        console.log('============= ' + posXName + ' =============');
        for (var i= 0; i < posX.length; i++) {
            console.log(pldump(posX[i] ^ colMask));
        }
    }

    // ====================================================================
    //  UI
    // ====================================================================

    function clickCell(move) {
        if (endTime) {
            status("Please wait until the computer made it's move!");
            return;
        }
        if (colAtMove(move)) {
            status("Cell is already taken!", 3);
            return;
        }
        var moves= unique(getValidMoves());
        var ok= 0;
        for (var movei in moves) {
            if (moves[movei] == move) { ok= 1; break; }
        }
        if (!ok) {
            status("Not a valid move!", 2);
            return;
        }
        setAt2[move]();
        refreshBoard();
        setTimeout(function() { computeMove(); }, 100);
    }

    function clickNewGame() {
        initBoard();
        refreshBoard();
    }

    function clickUndo() {
        if (boardLog.length <= 4) {
            console.log("CAN'T UNDO");
            return;
        }
        undo(2);
        refreshBoard();
    }
  
    function clickPass() {
        pass();
        refreshBoard();
        setTimeout(function() { computeMove(); }, 100);
    }

    function clickAutoPlay() {
        autoPlay();
        refreshBoard();
    }

    function clickTip() {
        refreshBoard();
        computeMove(1);
        return;
        
        var waitForMoved= function() {
            if (!endTime) {
                undo(1);
                refreshBoard();
                return;
            }
            setTimeout(waitForMoved, 100);
        }
        waitForMoved();
    }

    function doOnload() {

        initMovesCheck();
        initCellScore();

        makeGetValidMoves();

        setAt2= []
        for (var i= 0; i < 64; i++) {
            makeSetAt(i);
        }
        
        initPosList();

        var ready= function() {
            if (!initPosListDone) {
                setTimeout(ready, 100);
                return;
            }
            initBoard();
            printBoard();
        }
        setTimeout(ready, 100);
    }

</script>
<style>
    body {
        font-family: Tahoma, sans-serif;
        height: 100.1%;
        border: 0;
        margin: 0;
    }
    #board table {
        border-collapse: collapse;
        border: solid 6px #988579;
        background-color: #DABFAD;
    }
    #board table tr {
        vertical-align: top;
    }
    #board table td {
        border: solid 3px #B8A192;
        width: 40px;
        height: 40px;
        text-align: center;
        cursor: pointer;
    }
    #board .cell {
        position: relative;
        overflow: hidden;
        width: 40px;
        height: 40px;
    }
    #board .cell div {
        width: 40px;
        text-align: center;
        position: absolute;
        margin: 0;
        padding: 0;
    }
    #board .cell .num {
        font-size: 8px;
        color: #FFF;
    }
    #board .cell .stone-bg, #board .cell .stone-fg {
        top: -16px;
        font-size: 300%;
    }
    #board .cell .stone-bg {
        color: #fff;
    }
    #board .valid-move-1 {
        background-color: #F2D4C0;  /* whitish */
    }
    #board .valid-move-2 {
        background-color: #A79285;  /* blackish */
    }
    /* red: E55252 yellow: E5E052 */
    #board .last-move {
        background-color: #52C1E5;  /* blue */
    }
    #board .tip-move {
        background-color: #52E574;  /* green */
    }
    #console {
        padding: 20px;
        margin: 20px;
        border: 1px solid #888;
    }
    .button {
        -moz-border-radius: 6px;
        -webkit-border-radius: 6px;
        padding: 4px 10px;
        border: solid 2px black;
        background-color: #EEE;
        text-decoration: none;
        color: #000;
    }
    .button:hover {
        background-color: #DDD;
    }
    .debug {
        x-display: none;
    }
    #head {
        background-color: black;        
        padding: 10px 20px ;
        margin: 0 0 20px 0;
        color: #FFF;
        text-align: right;
    }
    #head h1 {
        float: left;
        text-weight: bold;
        font-size: 100%;
        padding: 0;
        margin: 0;
        color: #F2D4C0;
    }
    #head a {
        color: #FFF;
    }
    #body {
        padding: 10px;
    }
</style>
<body onload="doOnload()">
    <div id="head">
        <h1>MoReversi</h1>
        (c) 2008 by Dietrich Raisin, info@raisin.de, <a href="http://www.raisin.de/">www.raisin.de</a>
    </div>
    <div id="body">
        <div>
            <a class="button" href="javascript:clickNewGame();">New Game</a>
            <a class="button" href="javascript:clickUndo();">Undo</a>
            <a class="button" href="javascript:clickPass();">Pass</a>
            <a class="button" href="javascript:clickTip();">Tip</a>
            Time: <input id="time" size="2" value="8">s
        
            <span class="debug">
                <a class="button" href="javascript:clickDump('posH');">posH</a>
                <a class="button" href="javascript:clickDump('posV');">posV</a>
                <a class="button" href="javascript:clickDump('posDiag1');">posDiag1</a>
                <a class="button" href="javascript:clickDump('posDiag2');">posDiag2</a>
                <a class="button" href="javascript:clickDump('validMoves');">validMoves</a>
            </span>
        </div>
        <br />
        <div id="status">&nbsp;</div>
        <br />
        <div id="board"></div>
        <div id="console" class="debug"></div>
    </div>
</body>
