<script>

    var boardLog;

    var posH;
    var posV;
    var posDiag1;
    var posDiag2;

    var col;
    var colMask;
    var colDiff;
    
    var diff;

    var posList;
    var initPosListDone= 0;
    
    var undefined= undefined;   // jQuery does that. So it's correct. qed.

    function initBoard() {
        posH= [];
        posV= [];
        posDiag1= [];
        posDiag2= [];
        
        for (var y= 8; y--; ) {
            posH.push(0);
            posV.push(0);
        }

        for (var y= 15; y--; ) {
            posDiag1.push(0);
            posDiag2.push(0);
        }
        
        boardLog= [];

        col= 1;
        colMask= 0;
        colDiff= 1;
        
        diff= 0;

        setAt(27);
        setAt(28);
        setAt(36);
        setAt(35);

    }

    // ====================================================================
    //  OUTPUT
    // ====================================================================

    function printBoard() {

        var html= '<table>';
        var i= 0;
        for (var y= 0; y < 8; y++) {
            html += '<tr>';
            for (var x= 0; x < 8; x++, i++) {
                html += '<td onclick="clickCell(' + i + ')" id="cell' + i + '"></td>';
            }
            html += '</tr>';
        }
        html += '</table>';
        document.getElementById('board').innerHTML= html;

        refreshBoard();
    }

    function refreshBoard() {
        var i= 0;
        for (var y= 0; y < 8; y++) {
            var pos= posH[y];
            for (var x= 0; x < 8; x++) {
                (document.getElementById('cell' + i) || {}).innerHTML=
                    '<p class="num">' + i + '</p>' + '.OX'.substr(pos & 3, 1);
                pos >>= 2;
                i++;
            }
        }
        getValidMoves();
    }

    function unmarkAllCells() {
        for (var i= 0; i < 64; i++) {
            (document.getElementById('cell' + i) || {}).className= '';
        }
    }

    function markCell(cell, class_) {
         (document.getElementById('cell' + cell) || {}).className= class_;
    }

    // ====================================================================
    // ====================================================================

    function Y(move, pos0) {

        var pos= pos0 >> (move * 2);
        var j= 8 - move;
        var has2= 0;
        while (j--) {
            if ((pos & 3) == 1) break;
            if ((pos & 3) == 2) { has2++; continue; }
            if (!has2) break;
            console.log("left=" + has2);           
        }
        

    }

    function X(i) {
        return posList[i];
    }
    
    // ====================================================================
    // ====================================================================

    //  The entries for all possible positions for one row are stored in the
    //  posList array. The index consists of 2 * 8 bits for the 8 cells. 2 bits
    //  are used as follows: 0= empty, 1=white, 2=black, 3=empty.
    //
    //  The entries can be used for either opponent. One of the opponent
    //  looks up posList[n], the other posList[n ^ 0xffff].
    //
    //  Each entry look as follows:
    //  [ valid2, valid1, valid0,
    //      newpos0, newpos1, newpos2, newpos3, newpos4, newpos5, newpos6, newpos7,
    //      flipped
    //  ]
    //
    //  validN      Valid moves for white in that position.
    //
    //  newposN     New position if white's move is N.
    //              The new position includes the flipped captures stones if there are any.
    //
    //  flippedN    Number of flipped stones if white's move is N.

    function initPosList() {
    
        posList= new Array(65536);

        var pos0= 0;

        var nextChunk= function() {

            var pos,
                had, had1pos,
                want1, want2, wantpos,
                j,
                valid,
                flipped;

            for (chunk= 8192; chunk--; pos0++) {
    
                pos= newpos= pos0;
                had= want1= want2= 0;
                had1pos= wantpos= -1;
                valid= [ 9, 9, 9 ];
                newpos= [ pos0, pos0, pos0, pos0, pos0, pos0, pos0, pos0 ];
                flipped= [ 0, 0, 0, 0, 0, 0, 0, 0 ];
                validi= 0;
    
                for (j= 0; j < 8; j++) {
    
                    if ((pos & 3) == 1) {
                        if (wantpos >= 0) {
                            if (want2) {
                                valid[validi++]= wantpos;
                                
                                // Flip captured stones
                                newpos[wantpos] ^=
                                    ~(-1 << (j + j - wantpos - wantpos - 2))
                                    << (wantpos + wantpos + 2);
                                flipped[wantpos] += j - wantpos -1;
                            }
                            wantpos= -1;
                        }
                        had= 1;
                        want2= 0;
                        newpos[j]= undefined;
                    }
                    else if ((pos & 3) == 2) {
                        if (had == 1) {
                            had= 2;
                            had1pos= j;
                        }
                        want2= 1;
                        newpos[j]= undefined;
                    }
                    else {
                        if (had == 2) {
                            valid[validi++]= j;

                            // Flip captured stones
                            newpos[j] ^=
                                ~(-1 << (j + j - had1pos - had1pos))
                                << (had1pos + had1pos);
                            flipped[j] += j - had1pos;
                        }
                        wantpos= j;
                        had= want1= want2= 0;

                        newpos[j]= newpos[j]
                            & ~(3 << (j + j))
                            |   1 << (j + j);
                    }
                    pos >>= 2;
                }

                // Additionally to it's purpose, "concat" clones the array, which is
                // what we need here.
                posList[pos0]= valid.sort().reverse().concat(newpos).concat(flipped);

                // console.log(valid);
            }
            if (pos0 < 65536) {
                setTimeout(nextChunk, 1);
                return;
            }
            initPosListDone= 1;
            console.log("initPosList DONE");
        }
        setTimeout(nextChunk, 1);
    }

    function getValidMoves() {

        var checkValid= function(move, fvv, label, base, mul, len) {
            var valid= posList[fvv ^ colMask];
            var i= 3;
            while (i--) {
                if (valid[i] > len) break;

                var cell= base + mul * valid[i];
                console.log(label + ": valid(" + move + "," + '.OX'.substr(col, 1) + ")="
                    + cell
                    + ' (base=' + base + ' valid[' + i + ']=' + valid[i] + ')'
                );

                markCell(cell, 'valid-move');
            }
        }

        unmarkAllCells();

        for (var i= 0; i < 8; i++) {
            checkValid(i, posH[i],  'V  ', i * 8, 1, 8);
            checkValid(i, posV[i],  'H  ', i,     8, 8);
        }
        for (var i= 2; i < 8; i++) {
            checkValid(i, posDiag1[i], 'D1A', 7 - i, 9,  i);
            checkValid(i, posDiag2[i], 'D2A', i * 8, -7, i);
        }
        for (var i= 8; i < 13; i++) {
            checkValid(i, posDiag1[i], 'D1B', (i - 7) * 8, 9,  15 - i);
            checkValid(i, posDiag2[i], 'D2B', 49 + i,      -7, 15 - i);
        }
    }

    function pldump(pos, movei) {

    console.log(pos);
    console.log(posList[pos]);

        var newpos= movei == undefined
            ? pos
            : posList[pos][3 + movei];
        var i= 8;
        var result= movei + ': ';
        while (i--) {
            result += '.OX,'.substr((newpos ^ colMask) & 3, 1);
            newpos >>= 2;
        }
        return result;
    }

    function setAt(move) {
        var movey= move >> 3;
        var movex= move & 7;
        var pos;

        boardLog[boardLog.length]= move;
        diff += colDiff;

        // ==== posH ====

// console.log('A: ' + pldump(posH[movey] ^ colMask));
// console.log('B: ' + pldump(posH[movey] ^ colMask, movex));

        pos= posList[posH[movey] ^ colMask];
        diff += colDiff * pos[movex + 11] * 2;
        posH[movey]= (pos[movex + 3] ^ colMask) & ~(3 << (movex + movex)) | (col << (movex + movex));

// console.log('C: ' + pldump(posH[movey] ^ colMask) + ' diff=' + diff);

        // ==== posV ====

        pos= posList[posV[movex] ^ colMask];
        diff += colDiff * pos[movey + 11] * 2;
        posV[movex]= (pos[movey + 3] ^ colMask) & ~(3 << (movey + movey)) | (col << (movey + movey));

/*
        posV[movex] |= col << (movey * 2);

        // ---------

        var movey1= movey - movex + 7;
        var movex1= movex >= movey ? movey : movex;

        console.log('movey1=' + movey1 + ' movex1=' + movex1);

        // ---------

        posDiag1[movey1] |= col << (movex1 * 2);

        // checkValid(posDiag1[movey1], 'D1', base1, 9);

        // ---------

        var movey2= movey + movex;
        var movex2= (7 - movex) >= movey ? movex : 7 - movey;

        posDiag2[movey2] |= col << (movex2 * 2);


        console.log('movey2=' + movey2 + ' movex2=' + movex2);
*/

        col= 3 - col;
        colMask= 65535 - colMask;
        colDiff= -colDiff;
    }

    // slow! but doesn't matter, not used by computer player
    function undo() {
        var flog2= boardLog.concat(); // clone

        initBoard();        
        for (var i= 4; i < flog2.length - 1; i++) {
            setAt(flog2[i]);
        }
    }

    function clickUndo() {
        if (0 && boardLog.length <= 4) {
            console.log("CAN'T UNDO");
            return;
        }
        undo();
        refreshBoard();
    }
  
    function colAtMove(move) {
        var movey= move >> 3;
        var movex= move & 7;
        var result= (posH[movey] >> (movex + movex)) & 3;
        return result == 3 ? 0 : result;
    }
  
    function clickCell(move) {
        if (colAtMove(move)) {
            console.log("CELL ALREADY TAKEN");
            return;
        }
        setAt(move);
        refreshBoard();
    }

    function doOnload() {
        initPosList();

        var ready= function() {
            if (!initPosListDone) {
                setTimeout(ready, 100);
                return;
            }
            initBoard();
            printBoard();
        }
        setTimeout(ready, 100);
    }

</script>
<style>
    #board table {
        border: solid 1px #000;
    }
    #board table tr {
        vertical-align: center;
    }
    #board table td {
        border: solid 1px #000;
        width: 40px;
        height: 40px;
        text-align: center;
        cursor: pointer;
    }
    #board .num {
        font-size: 8px;
        color: blue;
        margin: 0;
        padding: 0;
    }
    #board .valid-move {
        background-color: yellow;
    }
    
</style>
<body onload="doOnload()">
    <a href="javascript:clickUndo();">UNDO</a>
    <hr>
    <div id="board"></div>
</body>