<script>

    if (!console) {

        // Firebug Feather :-)
        console= {
            log: function(value) {
                var lines= document.getElementById('console').innerHTML.split('<br>');
                lines.push(value);
                while (lines.length > 15) lines.shift();
                document.getElementById('console').innerHTML= lines.join('<br>');
            }
        };
    }

    var boardLog;

    var posH;
    var posV;
    var posDiag1;
    var posDiag2;

    var col;
    var colMask;
    var colDiff;
    
    var diff;

    var posList;
    var initPosListDone= 0;
    
    var undefined= undefined;   // jQuery does that. So it's correct. qed.

    var getValidMoves;
    var validMovesCheck;

    var hStatusTimer= null;

    var endTime= 0;

    function initBoard() {
        posH= [];
        posV= [];
        posDiag1= [];
        posDiag2= [];
        validMovesCheck= [];
        
        for (var y= 8; y--; ) {
            posH.push(0);
            posV.push(0);
        }

        for (var y= 15; y--; ) {
            posDiag1.push(0);
            posDiag2.push(0);
        }

        for (var i= 64; i--; ) {
            validMovesCheck.push(0);
        }
        
        boardLog= [];

        col= 1;
        colMask= 0;
        colDiff= 1;
        
        diff= 0;

        setAt(27);
        setAt(28);
        setAt(36);
        setAt(35);

    }

    // ====================================================================
    //  OUTPUT
    // ====================================================================

    // See: http://de.wikipedia.org/wiki/Benutzer:Buncic/Unicode/Geometrische_Formen
    function stone(col) {
        return ' \u25CB\u25CF '.substr(col & 3, 1);
    }

    function stoneBg(col) {
        return ' \u25CF  '.substr(col & 3, 1);
    }

    function status(html, secs) {
        console.log('STATUS: ' + html);
        document.getElementById('status').innerHTML= html;
        if (hStatusTimer) {
            clearTimeout(hStatusTimer);
            hStatusTimer= null;
        }
        if (secs) {
            hStatusTimer= setTimeout(function() {
                document.getElementById('status').innerHTML= 'Next move: ' + stone(col);
            }, secs * 1000);
        }
    }

    function printBoard() {

        var html= '<table>';
        var i= 0;
        for (var y= 0; y < 8; y++) {
            html += '<tr>';
            for (var x= 0; x < 8; x++, i++) {
                html += '<td onclick="clickCell(' + i + ')" id="cell' + i + '"></td>';
            }
            html += '</tr>';
        }
        html += '</table>';
        document.getElementById('board').innerHTML= html;

        refreshBoard();
    }

    function refreshBoard() {
        var i= 0;
        for (var y= 0; y < 8; y++) {
            var pos= posH[y];
            for (var x= 0; x < 8; x++) {
                (document.getElementById('cell' + i) || {}).innerHTML=
                    '<p class="num">' + i + '</p>'
                    + '<div class="stone">'
                    +     '<div class="bg">' + stoneBg(pos) + '</div>'
                    +     '<div>' + stone(pos) + '</div>'
                    + '</div>';
                pos >>= 2;
                i++;
            }
        }
        var cells= getValidMoves();
        markCells(cells);
    }

    function unmarkAllCells() {
        for (var i= 0; i < 64; i++) {
            (document.getElementById('cell' + i) || {}).className= '';
        }
    }

    function markCell(cell, class_) {
         (document.getElementById('cell' + cell) || {}).className= class_;
    }

    // ====================================================================
    //  Debugging
    // ====================================================================

    function pldump(pos, movei) {

    // console.log(pos);
    // console.log(posList[pos]);

        var newpos= movei == undefined
            ? pos
            : posList[pos][3 + movei];
        var i= 8;
        var result= movei + ': ';
        while (i--) {
            result += stone(newpos ^ colMask);
            newpos >>= 2;
        }
        return result + ' ' + pos;
    }

    function clickDump(posXName) {
        if (posXName == 'validMoves') {
            console.log(getValidMoves());
            return
        }
        var posX;
        if (posXName == 'posH') posX= posH;
        if (posXName == 'posV') posX= posV;
        if (posXName == 'posDiag1') posX= posDiag1;
        if (posXName == 'posDiag2') posX= posDiag2;
        console.log('============= ' + posXName + ' =============');
        for (var i= 0; i < posX.length; i++) {
            console.log(pldump(posX[i] ^ colMask));
        }
    }

    // ====================================================================
    // ====================================================================

    //  The entries for all possible positions for one row are stored in the
    //  posList array. The index consists of 2 * 8 bits for the 8 cells. 2 bits
    //  are used as follows: 0= empty, 1=white, 2=black, 3=empty.
    //
    //  The entries can be used for either opponent. One of the opponent
    //  looks up posList[n], the other posList[n ^ 0xffff].
    //
    //  Each entry look as follows:
    //  [ valid2, valid1, valid0,
    //      newpos0, newpos1, newpos2, newpos3, newpos4, newpos5, newpos6, newpos7,
    //      flipped
    //  ]
    //
    //  validN      Valid moves for white in that position.
    //
    //  newposN     New position if white's move is N.
    //              The new position includes the flipped captures stones if there are any.
    //
    //  flippedN    Number of flipped stones if white's move is N.

    function initPosList() {
    
        posList= new Array(65536);

        var pos0= 0;

        var nextChunk= function() {

            var pos,
                had, had1pos,
                want1, want2, wantpos,
                j,
                valid,
                flipped;

            for (chunk= 8192; chunk--; pos0++) {
    
                pos= newpos= pos0;
                had= want1= want2= 0;
                had1pos= wantpos= -1;
                valid= [ 9, 9, 9 ];
                newpos= [ pos0, pos0, pos0, pos0, pos0, pos0, pos0, pos0 ];
                flipped= [ 0, 0,  0, 0,  0, 0,  0, 0,  0, 0,  0, 0,  0, 0,  0, 0 ];
                validi= 0;
    
                for (j= 0; j < 8; j++) {
    
                    if ((pos & 3) == 1) {
                        if (wantpos >= 0) {
                            if (want2) {
                                valid[validi++]= wantpos;
                                
                                // Flip captured stones
                                newpos[wantpos] ^=
                                    ~(-1 << (j + j - wantpos - wantpos - 2))
                                    << (wantpos + wantpos + 2);
                                flipped[wantpos + wantpos + 1]= j - wantpos -1;
                            }
                            wantpos= -1;
                        }
                        had= 1;
                        want2= 0;
                        newpos[j]= undefined;
                    }
                    else if ((pos & 3) == 2) {
                        if (had == 1) {
                            had= 2;
                            had1pos= j;
                        }
                        want2= 1;
                        newpos[j]= undefined;
                    }
                    else {
                        if (had == 2) {
                            valid[validi++]= j;

                            // Flip captured stones
                            newpos[j] ^=
                                ~(-1 << (j + j - had1pos - had1pos))
                                << (had1pos + had1pos);
                            flipped[j + j]= j - had1pos;
                        }
                        wantpos= j;
                        had= want1= want2= 0;

                        newpos[j]= newpos[j]
                            & ~(3 << (j + j))
                            |   1 << (j + j);
                    }
                    pos >>= 2;
                }

                // Additionally to it's purpose, "concat" clones the array, which is
                // what we need here.
                posList[pos0]= valid.sort().reverse().concat(newpos).concat(flipped);

                // console.log(valid);
            }
            if (pos0 < 65536) {
                setTimeout(nextChunk, 1);
                return;
            }
            initPosListDone= 1;
            console.log("initPosList DONE");
        }
        setTimeout(nextChunk, 1);
    }

    // Builds an optimized function that calculated the valid moves.
    // The resulting function contains no loops, but too many ifs :-/
    function makeGetValidMoves() {

        var result= [];

        result.push(""
            , "\n    function() {"
            , "\n       var check= validMovesCheck.concat();"
            , "\n       var valid, cell;"
            , "\n       var result= [];"
        );

        var checkValid= function(posArray, move, base, mul, len) {

            // result[result.length] is faster than result.push, according to the net

            result.push(""
                , "\n       valid= posList[" + posArray + "[" + move + "] ^ colMask];"
            );

            if (mul == -1) mul= ' - ';
            else if (mul == 1) mul= (base ? ' + ' : '');
            else if (mul > 0) mul= (base ? ' + ' : '') + mul + ' * ';
            else mul= (base ? ' - ' : ' -') + -mul + ' * ';

            if (base == 0) base= '';

            var i= 3;
            while (i--) {
                result.push(""
                    , "\n       if (valid[" + i + "] < " + len + ") {"
                    , "\n           cell= " + base + mul + "valid[" + i + "];"
                    , "\n           if (check[cell] == 0) {"
                    , "\n               check[cell]= 1;"
                    , "\n               result[result.length]= cell;"
                    , "\n           }"
                    , "\n       }"
                );
            };
        }

        for (var i= 0; i < 8; i++) {
            checkValid('posH',      i, i * 8, 1, 8);
            checkValid('posV',      i, i,     8, 8);
        }
        for (var i= 2; i < 8; i++) {
            checkValid('posDiag1',  i, 7 - i, 9,  i);
            checkValid('posDiag2',  i, i * 8, -7, i);
        }
        for (var i= 8; i < 13; i++) {
            checkValid('posDiag1',  i, (i - 7) * 8, 9,  15 - i);
            checkValid('posDiag2',  i, 49 + i,      -7, 15 - i);
        }

        result.push(""
            , "\n       return result;"
            , "\n   }"
        );

        eval("getValidMoves= (" + result.join('') + ");");
    }

    function markCells(cells) {
        unmarkAllCells();
        for (var i in cells) markCell(cells[i], 'valid-move');
    }

    function setAt(move) {
        var movey= move >> 3;
        var movex= move & 7;
        var pos, qi;

        var movex2, movey2;
        var movexd, moveyd;

        var qmovex, qmovey;
        var qmovex2, qmovey2;
        var qmovexd, qmoveyd;

        var quickSetAt= function(dx, dy) {

            qmovex= movex;
            qmovey= movey;

            while (qi) {

                diff += colDiff + colDiff;

                // console.log("QUICKSET x=" + qmovex + " y=" + qmovey + " diff=" + diff);

                qmovex += dx;
                qmovey += dy;
                qmovex2= qmovex + qmovex;
                qmovey2= qmovey + qmovey;

                posH[qmovey]= posH[qmovey] & ~(3 << qmovex2) | (col << qmovex2);
    
                posV[qmovex]= posV[qmovex] & ~(3 << qmovey2) | (col << qmovey2);
    
                qmovexd= qmovex >= qmovey ? qmovey2 : qmovex2;
                qmoveyd= qmovey - qmovex + 7;
                posDiag1[qmoveyd]= posDiag1[qmoveyd] & ~(3 << qmovexd) | (col << qmovexd);
    
                qmovexd= (7 - qmovex) >= qmovey ? qmovex2 : 14 - qmovey2;
                qmoveyd= qmovey + qmovex;
                posDiag2[qmoveyd]= posDiag2[qmoveyd] & ~(3 << qmovexd) | (col << qmovexd);

                qi--;
            }
        };

        boardLog[boardLog.length]= move;
        diff += colDiff;

        movex2= movex + movex;
        movey2= movey + movey;

        pos= posList[posH[movey] ^ colMask];
        posH[movey] |= col << movex2;

        if (qi= pos[movex2 + 11]) quickSetAt(-1, 0);
        if (qi= pos[movex2 + 12]) quickSetAt( 1, 0);

        pos= posList[posV[movex] ^ colMask];
        posV[movex] |= col << movey2;

        if (qi= pos[movey2 + 11]) quickSetAt(0, -1);
        if (qi= pos[movey2 + 12]) quickSetAt(0,  1);

        movexd= movex >= movey ? movey2 : movex2;
        moveyd= movey - movex + 7;
        pos= posList[posDiag1[moveyd] ^ colMask];
        posDiag1[moveyd] |= col << movexd;

        if (qi= pos[movexd + 11]) quickSetAt(-1, -1);
        if (qi= pos[movexd + 12]) quickSetAt( 1,  1);

        movexd= (7 - movex) >= movey ? movex2 : 14 - movey2;
        moveyd= movey + movex;
        pos= posList[posDiag2[moveyd] ^ colMask];
        posDiag2[moveyd] |= col << movexd;

        if (qi= pos[movexd + 11]) quickSetAt(-1,  1);
        if (qi= pos[movexd + 12]) quickSetAt( 1, -1);

        col= 3 - col;
        colMask= 65535 - colMask;
        colDiff= -colDiff;

        // console.log("SETAT: diff=" + diff);
    }

    function pass() {
        if (boardLog.length >= 64) return;
        col= 3 - col;
        colMask= 65535 - colMask;
        colDiff= -colDiff;
    }

    // slow! but doesn't matter, not used by computer player
    function undo(count) {
        var flog2= boardLog.concat(); // clone

        initBoard();        
        for (var i= 4; i < flog2.length - count; i++) {
            setAt(flog2[i]);
        }
    }

    function clickUndo() {
        if (0 && boardLog.length <= 4) {
            console.log("CAN'T UNDO");
            return;
        }
        undo(2);
        refreshBoard();
    }
  
    function colAtMove(move) {
        var movey= move >> 3;
        var movex= move & 7;
        var result= (posH[movey] >> (movex + movex)) & 3;
        return result == 3 ? 0 : result;
    }
  
    function clickCell(move) {
        if (endTime) {
            status("Please wait until the computer made it's move!");
            return;
        }
        if (colAtMove(move)) {
            status("Cell is already taken!", 3);
            return;
        }
        var moves= getValidMoves();
        var ok= 0;
        for (var movei in moves) {
            if (moves[movei] == move) { ok= 1; break; }
        }
        if (!ok) {
            status("Not a valid move!", 2);
            return;
        }
        setAt(move);
        refreshBoard();
        setTimeout(function() { computeMove(); }, 100);
    }

    function clickPass() {
        pass();
        refreshBoard();
        setTimeout(function() { computeMove(); }, 100);
    }

    function autoPlay() {
        while (1) {
            var moves= getValidMoves();
            if (moves.length == 0) {
                pass();
                moves= getValidMoves();
                if (moves.length == 0) break;
            }
            var move= moves[Math.floor(Math.random() * moves.length)];
            setAt(move);
        }        
    }

    function clickAutoPlay() {
        autoPlay();
        refreshBoard();
    }

    var capPosH= [], capPosV= [], capPosDiag1= [], capPosDiag2= [], capBoardLog= [];
    var capCol, capColMask, capColDiff, capDiff;

    function captureBoard() {

        for (var y= 8; y--; ) {
            capPosH[y]= posH[y];
            capPosV[y]= posV[y];
        }

        for (var y= 15; y--; ) {
            capPosDiag1[y]= posDiag1[y];
            capPosDiag2[y]= posDiag2[y];
        }

        capBoardLog.splice(boardLog.length, 64);
        
        for (var i= boardLog.length; i--; ) {
            capBoardLog[i]= boardLog[i];
        }
        
        capCol= col;
        capColMask= colMask;
        capColDiff= colDiff;
        capDiff= diff;
        
        return;

        // Originally it was like this, but concat seemes to have
        // an insane implementation in FF3, it swallows memory faster
        // that you can look.
        /*
            return {
                boardLog: boardLog.concat(),
                col: col,
                colMask: colMask,
                colDiff: colDiff,
                diff: diff,
                posH: posH.concat(),
                posV: posV.concat(),
                posDiag1: posDiag1.concat(),
                posDiag2: posDiag2.concat()
            };
        */
    }

    function restoreBoard() {

        col= capCol;
        colMask= capColMask;
        colDiff= capColDiff;
        diff= capDiff;

        var tmp;
        
        tmp= boardLog;
        boardLog= capBoardLog;
        capBoardLog= tmp;

        tmp= posH;
        posH= capPosH;
        capPosH= tmp;

        tmp= posV;
        posV= capPosV;
        capPosV= tmp;

        tmp= posDiag1;
        posDiag1= capPosDiag1;
        capPosDiag1= tmp;

        tmp= posDiag2;
        posDiag2= capPosDiag2;
        capPosDiag2= tmp;
    }

    function computeMove() {
        var moves= getValidMoves();
        if (moves.length == 0) {
            pass();
            return;
        }

        var secs= document.getElementById('time').value;
        if (secs < 1) secs= 1;

        endTime= new Date().getTime() + secs * 1000;

        var moveScore= {};
        for (var movei in moves) {
            moveScore[moves[movei]]= 0;
        }

        var games= 0;
        var dots= '';

        var inner= function() {

            if (new Date().getTime() < endTime) {

                status("Thinking" + dots);
                dots += '.';
                for (var n= 0; n < 20; n++) {
                    for (var movei in moves) {
                        captureBoard();
                        setAt(moves[movei]);
                        autoPlay();
                        // console.log(capture.col);

                        if (capCol == 1) {
                            if (diff > 0) moveScore[moves[movei]] += 2;
                            if (diff < 0) moveScore[moves[movei]] -= 3;
                        }
                        else {
                            if (diff < 0) moveScore[moves[movei]] += 2;
                            if (diff > 0) moveScore[moves[movei]] -= 3;
                        }

                        restoreBoard();
                        games++;
                    }
                }
                setTimeout(inner, 10);
                return;
            }

            endTime= 0;
    
            // console.log("col=" + col);
            moves.sort(function(a, b) { return moveScore[b] - moveScore[a]; });
    
            var move= moves[0];
            setAt(move);
            refreshBoard();

            markCell(move, 'last-move');
    
            status('Done.'
                    + ' My move is (' + move + ') ' + (move & 7) + ',' + (move >> 3) + '.'
                    + ' Calculated ' + games + ' games.'
                , 3);
            
            // console.log(moves);
            // console.log(moveScore);
        }

        setTimeout(inner, 10);
    }

    function doOnload() {
        initPosList();

        makeGetValidMoves();

        var ready= function() {
            if (!initPosListDone) {
                setTimeout(ready, 100);
                return;
            }
            initBoard();
            printBoard();
        }
        setTimeout(ready, 100);
    }

</script>
<style>
    body {
        font-family: Tahoma, sans-serif;
    }
    #board table {
        border-collapse: collapse;
        border: solid 6px #988579;
        background-color: #DABFAD;
    }
    #board table tr {
        vertical-align: top;
    }
    #board table td {
        border: solid 3px #B8A192;
        width: 40px;
        height: 40px;
        text-align: center;
        cursor: pointer;
    }
    #board .num {
        font-size: 8px;
        color: blue;
        margin: 0;
        padding: 0;
    }
    #board .stone {
        position: relative;
    }
    #board .stone div {
        width: 40px;
        text-align: center;
        position: absolute;
        top: -25px;
        font-size: 300%;
        margin: 0;
        padding: 0;
    }
    #board .stone .bg {
        color: #fff;
    }
    #board .valid-move {
        background-color: #E5E052;
    }
    /* green: 52E574 red: E55252 */
    #board .last-move {
        background-color: #52C1E5;
    }
    #console {
        padding: 20px;
        margin: 20px;
        border: 1px solid #888;
    }
</style>
<body onload="doOnload()">
    <a href="javascript:clickUndo();">UNDO</a>
    <a href="javascript:clickPass();">PASS</a>
    <a href="javascript:clickDump('posH');">posH</a>
    <a href="javascript:clickDump('posV');">posV</a>
    <a href="javascript:clickDump('posDiag1');">posDiag1</a>
    <a href="javascript:clickDump('posDiag2');">posDiag2</a>
    <a href="javascript:clickDump('validMoves');">validMoves</a>
    <a href="javascript:clickAutoPlay();">AUTOPLAY</a>
    <a href="javascript:computeMove();">computeMove</a>
    Time: <input id="time" size="2" value="5">
    <hr>
    <div id="status">&nbsp;</div>
    <hr>
    <div id="board"></div>
    <div id="console"></div>
</body>