    // 25: stabil - spielt besser?
    // 28: umbau auf positiv -> besser

    // ====================================================================
    //  MoThello Version 2008-08-20. Inspired by MoGo.
    //  (c) 2008 by Dietrich Raisin, info1@raisin.de, www.raisin.de
    //
    //  Released under the Artistic License 2.0. Here are the terms:
    //  http://www.opensource.org/licenses/artistic-license-2.0.php
    //
    //  To make a copy, this file is the only one you need. No images were
    //  used, the stones are unicode characters.
    //
    //  Lessons learned:
    //  - Hashes are slow
    //  - Function calls are slow
    //  - Generating new arrays is slow
    // ====================================================================

    if (typeof console == 'undefined') {

        // Firebug Feather :-)
        console= {
            log: function(value) {
                var lines= document.getElementById('console').innerHTML.split('<br>');
                lines.push(value);
                while (lines.length > 15) lines.shift();
                document.getElementById('console').innerHTML= lines.join('<br>');
            }
        };
    }

    var boardLog;               // Log of the moves made

    var posH;                   // Board from a horizontal point of view
    var posV;                   // Board from a vertical point of view
    var posDiag1;               // Board from a diagonal point of view
    var posDiag2;               // Board from the other diagonal point of view

    var col;                    // Current player's color. 1 (white) or 2 (black).
    var colMask;                // 0 if col == 1, or 0xFFFF if col == 2
    var colDiff;                // 1 if col == 1, or -1 if col == 2
    
    var diff;                   // Current score (if positive, points that white is ahead, otherwise -points that black is ahead)

    var posList;                // See initPosList
    var initPosListDone;
    
    var undefined= undefined;   // jQuery does that. So it's correct. qed.

    var getValidMoves;          // Function generated by makeGetValidMoves()
    var validMovesCheck;        // Flag indicating if the board is already initialized
    var validMoves;

    var zero64;                 // 64 x 0

/*
    var recalcValidHV;
    var recalcValidDiag;
    var validHV;
    var validDiag;
    var validMoves;
*/

    var hStatusTimer= null;     // Used by status(). Timer for switching back the status information to default value

    var endTime= 0;             // Used by computeMove()
    var stopCalculating;

    var cellScore;

    var setAt;

    var computerCol= 0;
    var oldComputerCol= 0;

    // ====================================================================
    //  Core
    // ====================================================================

    function initCellScore() {
        cellScore= [];
        for (var i= 0; i < 64; i++) {
            cellScore[i]= 2;
        }
        for (var i= 0; i < 8; i++) {
            cellScore[i] += 2;
            cellScore[i * 8] += 2;
            cellScore[i + 56] += 2;
            cellScore[i * 8 + 7] += 2;
        }
        for (var i= 2; i < 6; i++) {
            cellScore[i + 16]++;
            cellScore[i * 8 + 2]++;
            cellScore[i + 40]++;
            cellScore[i * 8 + 5]++;
        }
        cellScore[9]= cellScore[14]= cellScore[49]= cellScore[54]= 1;
    }

    function initBoard() {
        posH= [];
        posV= [];
        posDiag1= [];
        posDiag2= [];
        
        for (var y= 8; y--; ) {
            posH.push(0);
            posV.push(0);
        }

        for (var y= 15; y--; ) {
            posDiag1.push(0);
            posDiag2.push(0);
        }

        boardLog= [];

        // Black begins
        col= 2;
        colMask= 65535;
        colDiff= -1;

        stopCalculating= 0;
        
        diff= 0;
/*
        recalcValidHV= 0;
        recalcValidDiag= 0;
        validHV= validMovesCheck.concat();
        validDiag= validMovesCheck.concat();
        validMoves= [];
*/

        validMoves= [];

        setAt[28]();
        setAt[27]();
        setAt[35]();
        setAt[36]();
    }

    //  The entries for all possible positions for one row are stored in the
    //  posList array. The index consists of 2 * 8 bits for the 8 cells. 2 bits
    //  are used as follows: 0= empty, 1=white, 2=black, 3=empty.
    //
    //  The entries can be used for either opponent. One of the opponent
    //  looks up posList[n], the other posList[n ^ 0xffff].
    //
    //  Each entry looks like this:
    //  [ valid2, valid1, valid0,
    //      newpos0, newpos1, ... , newpos7,
    //      flipped0-left, flipped0-right, flipped1-left, flipped1-right, ... , flipped7-left, flipped7-right,
    //  ]
    //
    //  validN      0..  Valid moves for white in that position.
    //
    //  newposN     3..  New position if white's move is N.
    //              The new position includes the flipped captures stones if there are any.
    //
    //  flippedN    11.. Number of flipped stones to the left and to the right if white's move is N.
    //
    //  // set1N       27.. DOCME
    //
    //  // set2N       35.. DOCME
    //
    function initPosList() {
    
        initPosListDone= 0;
        posList= new Array(65536);

        var pos0= 0;

        var nextChunk= function() {

            var pos,
                had, had1pos,
                want1, want2, wantpos,
                j,
                valid,
                newpos, flipped; // , set1, set2;

            for (chunk= 8192; chunk--; pos0++) {
    
                pos= pos0;
                had= want1= want2= 0;
                had1pos= wantpos= -1;
                valid= [ 9, 9, 9 ];
                newpos= [ pos0, pos0, pos0, pos0, pos0, pos0, pos0, pos0 ];
                flipped= [ 0, 0,  0, 0,  0, 0,  0, 0,  0, 0,  0, 0,  0, 0,  0, 0 ];
                validi= 0;
    
                for (j= 0; j < 8; j++) {

                    if ((pos & 3) == 1) {
                        if (wantpos >= 0) {
                            if (want2) {
                                valid[validi++]= wantpos;
                                
                                // Flip captured stones
                                newpos[wantpos] ^=
                                    ~(-1 << (j + j - wantpos - wantpos - 2))
                                    << (wantpos + wantpos + 2);
                                flipped[wantpos + wantpos + 1]= j - wantpos -1;
                            }
                            wantpos= -1;
                        }
                        had= 1;
                        want2= 0;
                        newpos[j]= undefined;
                    }
                    else if ((pos & 3) == 2) {
                        if (had == 1) {
                            had= 2;
                            had1pos= j;
                        }
                        want2= 1;
                        newpos[j]= undefined;
                    }
                    else {
                        if (had == 2) {
                            valid[validi++]= j;

                            // Flip captured stones
                            newpos[j] ^=
                                ~(-1 << (j + j - had1pos - had1pos))
                                << (had1pos + had1pos);
                            flipped[j + j]= j - had1pos;
                        }
                        wantpos= j;
                        had= want1= want2= 0;

                        newpos[j]= newpos[j] & ~(3 << (j + j)) | (1 << (j + j));
                    }

                    pos >>= 2;
                }

                // Additionally to it's purpose of concating, "concat" clones the array, which is
                // what we need here.
                posList[pos0]= valid.sort().concat(newpos).concat(flipped); // .concat(set1).concat(set2);

                // console.log(valid);
            }
            if (pos0 < 65536) {
                setTimeout(nextChunk, 1);
                return;
            }
            initPosListDone= 1;
            console.log("initPosList DONE");
        }
        setTimeout(nextChunk, 1);
    }

    function unique(a) {
        var lookup= [];
        var result= [];
        for (var i= a.length; i--; ) {
            if (lookup[a[i]] == undefined) result[result.length]= a[i];
            lookup[a[i]]= 1;
        }
        return result;
    }

    function finished() {
        if (boardLog.length < 4) return true;
        if (boardLog[boardLog.length - 2] == 64 && boardLog[boardLog.length - 1] == 64) return true;
        if (getValidMoves()[0] == 64) {
            swapCol();
            var fin= getValidMoves()[0] == 64;
            swapCol();
            return fin;
        }
        return false;
    }

    function swapCol() {
        col= 3 - col;
        colMask= 65535 - colMask;
        colDiff= -colDiff;
    }
      
    function pass() {
        boardLog[boardLog.length]= 64;
        swapCol();
    }

    // slow! but doesn't matter, not used by computer player
    function undo(count) {
        var flog2= boardLog.concat(); // clone

        initBoard();
        for (var i= 4; i < flog2.length - count; i++) {
            setAt[flog2[i]]();
        }
    }

    // Retrieves the color of a given cell
    function colAtCell(cell) {
        var movey= cell >> 3;
        var movex= cell & 7;
        var result= (posH[movey] >> (movex + movex)) & 3;
        return result == 3 ? 0 : result;
    }
  
    var capPosH= [], capPosV= [], capPosDiag1= [], capPosDiag2= [];
    var capBoardLog= [];

    var capCol, capColMask, capColDiff;
    var capDiff;

    function captureBoard() {

        for (var y= 8; y--; ) {
            capPosH[y]= posH[y];
            capPosV[y]= posV[y];
        }

        for (var y= 15; y--; ) {
            capPosDiag1[y]= posDiag1[y];
            capPosDiag2[y]= posDiag2[y];
        }

        capBoardLog.splice(boardLog.length, 999);
        for (var i= boardLog.length; i--; ) {
            capBoardLog[i]= boardLog[i];
        }
        
        capCol= col;
        capColMask= colMask;
        capColDiff= colDiff;

        capDiff= diff;
    }

    function restoreBoard() {

        for (var y= 8; y--; ) {
            posH[y]= capPosH[y];
            posV[y]= capPosV[y];
        }

        for (var y= 15; y--; ) {
            posDiag1[y]= capPosDiag1[y];
            posDiag2[y]= capPosDiag2[y];
        }

        boardLog.splice(capBoardLog.length, 999);
        for (var i= capBoardLog.length; i--; ) {
            boardLog[i]= capBoardLog[i];
        }
/*
        validHV= [];
        validDiag= [];
        for (var i= 64; i--; ) {
            validHV[i]= capValidHV[i];
            validDiag[i]= capValidDiag[i];
        }

        validMoves= [];
        for (var i= capValidMoves.length; i--; ) {
            validMoves[i]= capValidMoves[i];
        }

        recalcValidHV= capRecalcValidHV;
        recalcValidDiag= capRecalcValidDiag;
*/
        
        col= capCol;
        colMask= capColMask;
        colDiff= capColDiff;

        diff= capDiff;
    }

    function computeMove(tip) {
        var moves= unique(getValidMoves());
        if (moves[0] == 64) {
            status('Pass. I can\'t make a move :-(', 3);
            if (!tip) pass();
            refreshBoard();
            return 0;
        }

        var secs= document.getElementById('time').value;
        if (secs < 1) secs= 1;

        var games= 0;
        var gamesPerMove= 0;

        var doMove= function(move) {
            if (!tip) {
                setAt[move]();
                refreshBoard();
                markCell(move, 'last-move');
            }
            else {
                updateUI();
                markCell(move, 'tip-move');
            }
    
            status('Done.'
                    // + ' My move is (' + move + ') ' + ((move & 7) + 1) + ',' + ((move >> 3) + 1) + '.'
                    + ' My move is ' + ((move & 7) + 1) + '-' + ((move >> 3) + 1) + '.'
                    + ' Calculated ' + games + ' games.'
                , 3);
        }

//        if (moves.length == 1) {
//            doMove(moves[0]);
//            return 1;
//        }

        var startTime= new Date().getTime();

        endTime= startTime + secs * 1000;

        // Start removing stupid moves from the list of considered moves after 1/3 of the time
        var cleanupTime= startTime + secs * 333;
        
        var scores= [];
/*
        for (var movei in moves) {
            scores[moves[movei]]= 0;
        }
*/
        captureBoard();

        var oppMoves= [];
        var oppScores= [];

        for (var movei in moves) {
            var move= moves[movei];

            setAt[move]();
            oppMoves[movei]= unique(getValidMoves());
            oppScores[movei]= zero64.concat().splice(0, oppMoves[movei].length);
            restoreBoard();
        }

        var dots= '';

        var time;
        var nextMoves;
        var nextMove;
        var move, movei;
        var oppMove, oppMovei;

        updateUI();

        var r= function(v) { var s= '        ' + (Math.round(v * 10) / 10); return s.substr(s.length - 8); };
        var prefix= function(alg, move) { return alg + " " + colName(col) + " " + ('' + (move + 100)).substr(1) + ":  "; };

        var avgScore= function(opps, oppm) {

// console.log(opps); console.log(oppm);

            var min= 999999999;
            var max= -999999999;
            var d= 0;
            var n= oppm ? oppm.length : opps.length;
            for (var i= n; i--; ) {
                var score= oppm ? opps[oppm[i]] : opps[i];
                if (score > max) max= score;
                if (score < min) min= score;
                d += score;
            }

            // returns contains the average score - 30% * (max - min).
            // Now all moves with scores > d can be removed.

            return d / n - (max - min) * 0.3;
        };

        /**
         *  Eliminate useless moves from the queue.
         */
        var reduceMoves= function() {

            var before= moves.length;
            var oppBefore= 0;
            var oppAfter= 0;

            // Reduce moves

            calcMoveScore();
            var d= avgScore(scores, moves);

            var newMoves= [];
            var newOppMoves= [];
            var newOppScores= [];
            for (var movei= moves.length; movei--; ) {
                if (scores[moves[movei]] < d) {
                    console.log("reduceMoves: eliminate " + moves[movei] + ", because " + scores[moves[movei]] + ' < ' + d);
                    continue;
                }
                oppBefore += oppMoves[movei].length;
                newMoves[newMoves.length]= moves[movei];
                newOppMoves[newOppMoves.length]= oppMoves[movei];
                newOppScores[newOppScores.length]= oppScores[movei];
            }
            moves= newMoves;
            oppMoves= newOppMoves;
            oppScores= newOppScores;

            // Reduce oppMoves

            for (var movei in moves) {
                var move= moves[movei];

                var oppm= oppMoves[movei];
                var opps= oppScores[movei];

                var d= avgScore(opps);

                var newOppMove=  [];
                var newOppScore= [];

                for (var oppMovei= oppm.length; oppMovei--; ) {
                    if (opps[oppMovei] < d) continue;
                    newOppMove[newOppMove.length]=   oppm[oppMovei];
                    newOppScore[newOppScore.length]= opps[oppMovei];
                }

                oppAfter += newOppMove.length;

                oppMoves[movei]=  newOppMove;
                oppScores[movei]= newOppScore;
            }

            console.log("reduceMoves: before=" + before + " after=" + moves.length + " oppBefore=" + oppBefore + " oppAfter=" + oppAfter);
        };    

        var calcMoveScoreOppMax= function() {
            scores= [];

            for (var movei in moves) {
                var move= moves[movei];

                var n= oppMoves[movei].length;
                var opps= oppScores[movei];

                var max= -999999;
                for (var oppMovei= n; oppMovei--; ) {
                    if (opps[oppMovei] > max) max= opps[oppMovei];
                }

                scores[move]= -max;

                if (1) {
                    console.log(prefix('OppMax', move) + "max=" + r(max) + " score=" + r(scores[move]));
                }
            }
        };    

        var calcMoveScoreTest1= function() {
            scores= [];

            for (var movei in moves) {
                var move= moves[movei];

                var n= oppMoves[movei].length;
                var opps= oppScores[movei];

                var d= 0;
                for (var oppMovei= n; oppMovei--; ) {
                    d += opps[oppMovei];
                }
                d /= n;

                var dd = 0;
                for (var oppMovei= n; oppMovei--; ) {
                    var score= opps[oppMovei];
                    dd -= score < d ? score : d + Math.pow(score - d, 2);
                }
                scores[move]= dd / n;

                if (1) {
                    console.log(prefix('Test1', move) + " score=" + r(scores[move]));
                }
            }
        };    

        var calcMoveScoreCK= function() {
            scores= [];

            // A3: -17 ...
            // A5: <f>(A3-25)^$A$1</f>
            // K5: <f>(SUM($A5:$G5)^(1/$A$1)*($A3)/COUNT($A3:$G3))</f>

            for (var movei in moves) {
                var move= moves[movei];

                var n= oppMoves[movei].length;
                var opps= oppScores[movei];
                var max= -99999999;
                var sum= 0;

                for (oppMovei= n; oppMovei--; ) {
                    var score= opps[oppMovei];
                    if (score > max) max= score;

                    sum += Math.pow(score - gamesPerMove, 8);
                }

                scores[move]= -Math.floor(Math.pow(sum, 1/8) * max / oppMoves[movei].length);

                console.log(prefix('CK', move) + ' score=' + scores[move]);
            }
        };    

        var calcMoveScore= function() {
            // capCol == 1 ? calcMoveScoreMin() : calcMoveScoreCK();     // Min 10s
            // capCol == 1 ? calcMoveScoreCK() : calcMoveScoreMin();     // Min 10s 17:27
            // capCol == 1 ? calcMoveScoreCK() : calcMoveScoreOppMax();     // Min 10s 17:27
            // calcMoveScoreOppMax();
            // calcMoveScoreOppMax();
            // calcMoveScoreCK();
            calcMoveScoreTest1();
        };

        var inner= function() {

            time= new Date().getTime();

            if (cleanupTime && time > cleanupTime) {
                reduceMoves();
                cleanupTime= Math.max(time + 500, (time + endTime) / 2);
            }

            if (moves.length > 1 && time < endTime) {

                status("Thinking" + dots, 0, 1);
                dots= dots.length > 30 ? '' : dots + '.';

                var nextTime= time + 100;
                while(true) {

                    time= new Date().getTime();
                    if (time > endTime || time > nextTime) break;

                    gamesPerMove++;

                    for (movei in moves) {
                        move= moves[movei];

                        for (oppMovei in oppMoves[movei]) {
                            oppMove= oppMoves[movei][oppMovei];

                            restoreBoard();
                            setAt[move]();

// console.log(oppMoves[move]);
                            setAt[oppMove]();

                            while (1) {
                                nextMoves= getValidMoves();
                                if (nextMoves[0] == 64) {
                                    pass();
                                    nextMoves= getValidMoves();
                                    if (nextMoves[0] == 64) break;
                                }
                                nextMove= nextMoves[Math.floor(Math.random() * nextMoves.length)];
                                setAt[nextMove]();
                            }        

                            if (capCol == 2) {
                                if (diff > 0) oppScores[movei][oppMovei]++;
                                if (diff < 0) oppScores[movei][oppMovei]--;
                            }
                            else {
                                if (diff < 0) oppScores[movei][oppMovei]++;
                                if (diff > 0) oppScores[movei][oppMovei]--;
                            }

                            games++;
                        }

                    }
                }
                setTimeout(inner, 50);
                return;
            }

            restoreBoard();
            endTime= 0;

            calcMoveScore();

            moves.sort(function(a, b) { return scores[b] - scores[a]; });

            // console.log(getValidMoves());

            var s= '';
            for (var movei in moves) {
                s += ' ' + moves[movei] + ':' + (Math.floor(scores[moves[movei]] * 10) / 10);
            }
            console.log("Scores:" + s);
    
            doMove(moves[0]);
            
            // console.log(scores);
        }

        setTimeout(inner, 10);
        return 1;
    }

    // ====================================================================
    //  Output
    // ====================================================================

    // See: http://de.wikipedia.org/wiki/Benutzer:Buncic/Unicode/Geometrische_Formen
    function stone(col) {
        return ' \u25CB\u25CF '.substr(col & 3, 1);
    }

    function stoneBg(col) {
        return ' \u25CF  '.substr(col & 3, 1);
    }

    function colName(col) {
        if (col == 1) return "White";
        if (col == 2) return "Black";
        return "?"
    }

    function defaultStatus() {
        clearTimeout(hStatusTimer);
        hStatusTimer= null;
        var status= finished() ? 'wins' : 'leads';
        if (diff > 0) {
            status= 'White ' + status + ' by ' + diff + ' points';
        }
        else if (diff < 0) {
            status= 'Black ' + status + ' by ' + (-diff) + ' points';
        }
        else {
            status= finished() ? 'it\'s a draw' : 'The game is even';
        }
        if (finished()) {
            status= 'Game over, ' + status + '!';
        }
        else {
            status= colName(col) + '\'s turn. ' + status + '.';
        }
        console.log(status);
        document.getElementById('status').innerHTML= status;
    }

    function status(html, secs, noConsole) {
        if (!noConsole) console.log('STATUS: ' + html);
        document.getElementById('status').innerHTML= html;
        if (hStatusTimer) {
            clearTimeout(hStatusTimer);
            hStatusTimer= null;
        }
        if (secs) {
            hStatusTimer= setTimeout(defaultStatus, secs * 1000);
        }
    }

    function printBoard() {

        var html= '<table cellspacing="0" cellpadding="0">';
        var i= 0;
        for (var y= 0; y < 8; y++) {
            html += '<tr>';
            for (var x= 0; x < 8; x++, i++) {
                html += '<td onclick="clickCell(' + i + ')" id="cell' + i + '"><div class="cell"></div></td>';
            }
            html += '</tr>';
        }
        html += '</table>';
        document.getElementById('board').innerHTML= html;
    }

    function refreshBoard() {
        var i= 0;
        for (var y= 0; y < 8; y++) {
            var pos= posH[y];
            for (var x= 0; x < 8; x++) {
                (document.getElementById('cell' + i) || {}).innerHTML=
                      '<div class="cell">'
                    +   '<div class="num debug">' + i + '</div>'
                    +   '<div class="stone-bg">' + stoneBg(pos) + '</div>'
                    +   '<div class="stone-fg">' + stone(pos) + '</div>'
                    + '</div>'
                pos >>= 2;
                i++;
            }
        }
        var cells= finished() ? [] : getValidMoves();

        unmarkAllCells();
        for (var i in cells) markCell(cells[i], 'valid-move-' + col);

        updateUI();
    }

    function unmarkAllCells() {
        for (var i= 0; i < 64; i++) {
            (document.getElementById('cell' + i) || {}).className= '';
        }
    }

    function markCell(cell, class_) {
         (document.getElementById('cell' + cell) || {}).className= class_;
    }

    // ====================================================================
    //  Debugging
    // ====================================================================

    function pldump(pos) {

        var newpos= pos;
        var i= 8;
        var result= '';
        while (i--) {
            result += '.OX,'.substr((newpos ^ colMask) & 3, 1);
            newpos >>= 2;
        }
        return result + ' ' + pos;
    }

    function clickDump(posXName) {
        if (posXName == 'sit') {
            var s= '';
            for (var i= 4; i < boardLog.length; i++) {
                s += 'setAt[' + boardLog[i] + '](); ';
                if (i & 1) s += ' ';
            }
            console.log(s);
            return;
        }
        if (posXName == 'validMoves') {
            console.log(getValidMoves());
            return
        }
        var posX;
        if (posXName == 'posH') posX= posH;
        if (posXName == 'posV') posX= posV;
        if (posXName == 'posDiag1') posX= posDiag1;
        if (posXName == 'posDiag2') posX= posDiag2;
        console.log('============= ' + posXName + ' =============');
        for (var i= 0; i < posX.length; i++) {
            console.log(pldump(posX[i] ^ colMask));
        }
    }

    // ====================================================================
    //  UI
    // ====================================================================

    function computing() {
        if (!initPosListDone) {
            status("Please wait until the game is ready!");
            return true;
        }
        if (endTime) {
            status("Please wait until the computer has made it's move!", 0, true);
            return true;
        }
        return false;
    }

    function stopping() {
        return stopCalculating;
    }

    function setComputerCol(newCol) {
        if (computerCol == 3) {
            oldComputerCol= newCol;
            return;
        }
        computerCol= newCol;
    }

    function updateUI() {
        var begun= boardLog.length > 4;
        var is_finished= finished();
        var computing= endTime;
        
        var up= function(button, on) {
            document.getElementById('button_' + button).className= on ? 'button' : 'button_off';
        };
        
        // <a id="button_new_game" class="button" href="javascript:clickNewGame();">New</a>
        up("new_game",  !computing && begun);
        up("undo",      !computing && begun);
        up("pass",      !computing && !is_finished);
        up("tip",       !computing && !is_finished);
        up("stop",      computing);
        up("settings",  true);
    }

    function clickCell(move) {
        if (computing() || finished()) return;
        
        if (colAtCell(move)) {
            status("Cell is already taken!", 3);
            return;
        }

        var moves= unique(getValidMoves());
        var ok= 0;
        for (var movei in moves) {
            if (moves[movei] == move) { ok= 1; break; }
        }
        if (!ok) {
            status("Not a valid move!", 2);
            return;
        }

        setAt[move]();
        refreshBoard();
        defaultStatus();
        markCell(move, 'last-move');

        if (computerCol & col) {
            computeMove();
        }
    }

    function clickNewGame() {
        if (computing() || boardLog.length <= 4) return;

        initBoard();
        refreshBoard();
        defaultStatus();

        if (computerCol & col) {
            computeMove();
        }
    }

    function clickUndo() {
        if (computing()) return;
        if (boardLog.length <= 4) {
            console.log("CAN'T UNDO");
            return;
        }

        undo(computerCol == 1 || computerCol == 2 ? 2 : 1);
        refreshBoard();
        defaultStatus();
        if (boardLog.length > 4) {
            if (boardLog[boardLog.length - 1] != 64) {
                markCell(boardLog[boardLog.length - 1], 'last-move');
            }
            else {
                status(colName(3 - col) + " passed.", 2);
            }
        }
    }

    function clickPass() {
        if (computing() || finished()) return;

        pass();
        refreshBoard();
        defaultStatus();

        if (computerCol & col) {
            computeMove();
        }
    }

    function clickTip() {
        if (computing() || finished()) return;

        refreshBoard();
        computeMove(1);
    }

    function clickStop() {
        if (!initPosListDone || !computing()) return;
        
        status("Stopping computation. Please hold on...");
        endTime= 1;
        stopCalculating= 1;
    }
    
    function clickSettings() {
        if (!initPosListDone) return;

        // document.getElementById('computer_col_0').enabled= computerCol != 3;
        // document.getElementById('computer_col_1').enabled= computerCol != 3;
        // document.getElementById('computer_col_2').enabled= computerCol != 3;
        document.getElementById('computer_col_' + (computerCol == 3 ? oldComputerCol : computerCol)).checked= 1;
        document.getElementById('settings').style.display= 'block';
    }

    function clickCloseSettings() {
        document.getElementById('settings').style.display= 'none';
        if (!computing() && (computerCol & col)) {
            computeMove();
        }
    }

    function clickAuto() {
        oldComputerCol= computerCol;
        computerCol= 3;

        stopCalculating= 0;

        var score= [0, 0];
        document.getElementById('button_auto').innerHTML= score.join(':');
        // aAuto.html.split(':');

        var wait= function() {
            if (!computing()) {
                if (!computeMove() && !computeMove()) {
                    computerCol= oldComputerCol;
                    console.log("GAME IS OVER");
                    defaultStatus();

                    score[diff > 0 ? 0 : 1]++;
                    document.getElementById('button_auto').innerHTML= score.join(':');

                    if (stopping()) return;

                    initBoard();
                }
            }
            if (!stopping()) setTimeout(wait, 500);
        }
        wait();
    }

    function doOnload() {

        status("Initializing, please hold on a second...");

        zero64= [];
        for (var i= 64; i--; ) zero64[i]= 0;

        initCellScore();
        getValidMoves= (function() {
            var _getValidMoves= makeGetValidMoves();
            return function() {
                return _getValidMoves(cellScore, colMask, posList, posH, posV, posDiag1, posDiag2);
            };
        })();
        printBoard();

        setAt= []
        for (var i= 64; i--; ) makeSetAt(i);
        setAt[64]= pass;
        
        initPosList();

        var ready= function() {
            if (!initPosListDone) {
                setTimeout(ready, 100);
                return;
            }
            initBoard();


            // seltsamer move von weiss
            // setAt[26](); setAt[34](); setAt[41](); setAt[18](); setAt[42](); setAt[25](); setAt[20](); setAt[33](); setAt[44](); setAt[53](); setAt[32](); setAt[40](); setAt[11](); setAt[10](); setAt[2](); setAt[17](); setAt[16](); setAt[24](); setAt[48]();
            // setAt[8](); setAt[0](); setAt[51](); setAt[19](); setAt[49](); setAt[50](); setAt[12](); setAt[21](); setAt[9](); setAt[5](); setAt[4](); setAt[60](); setAt[58](); setAt[29](); setAt[13](); setAt[6](); setAt[7](); setAt[3](); setAt[1](); setAt[59](); setAt[57](); setAt[43](); setAt[45](); setAt[37](); setAt[52](); setAt[61](); setAt[38](); setAt[31](); setAt[39](); setAt[56](); setAt[22](); setAt[47]();
            // setAt[62](); setAt[63](); setAt[30](); setAt[46]();
            // setAt[54](); setAt[55](); setAt[64](); setAt[14](); setAt[23](); setAt[15](); setAt[64](); 

            // setAt[44](); setAt[45](); setAt[19](); setAt[43](); setAt[37](); setAt[29](); setAt[30](); setAt[22](); setAt[38](); setAt[46](); setAt[21](); setAt[12](); setAt[5](); setAt[3](); setAt[13](); setAt[4](); setAt[2](); setAt[26](); setAt[42](); setAt[41](); setAt[20](); setAt[11](); setAt[10](); setAt[18](); setAt[34](); setAt[17](); setAt[6]();

            setAt[44](); setAt[45](); setAt[19](); setAt[43](); setAt[37](); setAt[29](); setAt[30](); setAt[22](); setAt[38](); setAt[46](); setAt[21](); setAt[12](); setAt[5](); setAt[3](); setAt[13](); setAt[4](); setAt[2](); setAt[26](); setAt[42](); setAt[41](); setAt[20](); setAt[11](); setAt[10](); setAt[18](); setAt[34](); setAt[17](); setAt[6](); setAt[9](); setAt[23](); setAt[31](); setAt[25](); setAt[24](); setAt[47](); setAt[33](); setAt[40](); setAt[53](); setAt[61](); setAt[50](); setAt[58](); setAt[55]();
            // setAt[51](); setAt[60](); setAt[59](); setAt[15](); setAt[62](); setAt[48](); setAt[0](); setAt[32](); setAt[63](); setAt[52](); setAt[1](); setAt[57](); setAt[16](); setAt[8](); setAt[56](); setAt[54](); setAt[39](); setAt[14](); setAt[7](); setAt[64](); setAt[49](); setAt[64](); 
			// setAt[44](); setAt[43](); setAt[42](); setAt[45](); setAt[29](); setAt[51](); setAt[34](); setAt[37](); setAt[19](); setAt[26](); setAt[38](); setAt[20](); setAt[46](); setAt[52](); setAt[58](); setAt[53](); setAt[61](); setAt[12](); setAt[4](); setAt[21](); setAt[13](); setAt[60](); setAt[10](); setAt[62](); setAt[25](); 
			
            refreshBoard();
            defaultStatus();
        }
        setTimeout(ready, 100);
    }
